================================================================================
INXI TOOLS
================================================================================
FILE:    inxi-tools.txt
VERSION: 1.6
DATE:    2021-02-08

----------------------------------------
Docs:
See: docs/inxi-data.txt
See: docs/inxi-resources.txt
See: docs/inxi-values.txt
See: docs/optimization.txt

----------------------------------------
Code: 
See:

----------------------------------------
Comments:

This constitues the essential internal 'api' of inxi, and is a reference 
document for programming inxi.

================================================================================

Sections:
1. CORE TOOLS
2. SPECIFIC TOOLS

================================================================================
CORE TOOLS
--------------------------------------------------------------------------------

These are the tools you'd use in working on features of inxi. That is, don't
reinvent the wheel, if a tool is already done, then use it. Most tools feature 
logging when the debugger logging flag is set, which is useful to seeing 
execution times and flows, as well as what was passed to the tools.

========================================
awk()
----------------------------------------

Emulates to some degree how awk works, pass it:

Duplicates the functionality of awk to allow for one liner
type data parsing. note: -1 corresponds to awk NF
args:
1: array of data; 
2: search term; 
3: field result - this is integer, starting at 1, not 0
4: separator - optional

corresponds to: awk -F='separator' '/search/ {print $2}' <<< @data
array is sent by reference so it must be dereferenced
NOTE: if you just want the first row, pass it \S as search string
NOTE: if $num is undefined, it will skip the second step

----------------------------------------
  CODE
----------------------------------------

$value = main::awk(\@data,'something',3);

========================================
check_program()
----------------------------------------

arg: 
1 - string or path to search generated @paths data for.

note: a few nano seconds are saved by using raw $_[0] for program

Returns full path in system, which can then be sent to program_version 
to save that step in looking for it. When program_version receives a file
name starting with /, it assumes it's a valid path and uses that.

----------------------------------------
  CODE
----------------------------------------

$path = main::check_program('lspci');

========================================
compare_versions()
----------------------------------------

Using string compare, and padding, returns the greather string value.
Note that each component of the version string is split by . - _ and then
each part is zero padded until being reassembled into one long string to
allow for normal string compare operation. String 0 padding to 4 zeros 
per component of the version string.

----------------------------------------
  CODE
----------------------------------------

# returns 1.20.1-b4

$version = main::compare_versions('1.20.1','1.20.1-b4');

========================================
count_dir_files()
----------------------------------------

Args:
1. Directory

returns count of files in directory, if 0, dir is empty

----------------------------------------
  CODE
----------------------------------------

$count = main::count_dir_files('/sys');

========================================
get_defined()
----------------------------------------

args: 
List with 2 or more members.

Returns first defined element of that list, otherwise returns implicit 
undefined.

----------------------------------------
  CODE
----------------------------------------

$value = main::get_defined($var1,$var2,$var3);

========================================
get_piece()
----------------------------------------

args: 
1 - the string to get piece of
2 - the position in string, starting at 1 for 0 index.
3 - the separator, default is ' '

----------------------------------------
  CODE
----------------------------------------

$result = main::get_piece($string,3,"\n");

========================================
get_size()
----------------------------------------

args: 
1 - numeric (or string value, it tests), value to create
unit output for, like numeric in, number plus units out.
If not numeric, returns string you passed it, that lets 
error messages etc get  preserved. 

2 - string/'' if string, returns string formatted with:
number Unit, like: 204.1 MiB
If $2 is '' or unset, returns array of number and unit.

3. - so you can skip if null tests when you call this tool,
if you pass the default null return value, like 'N/A' if the
number value is null, it returns the default null value.

Note with default null, if you do not want the item to 
print if null, leave 3 undefined, and test for null
on item create in the output sub or wherever it is.

----------------------------------------
  CODE
----------------------------------------

$size = main::get_size($number,'string','N/A');

========================================
globber()
----------------------------------------

args: 
1 - string value to glob

Note: returns full path per result.

----------------------------------------
  CODE
----------------------------------------

@files = main::globber('/sys/*/*');

========================================
grabber()
----------------------------------------

args: 
1 - command to turn into an array; 
2 - optional: splitter - default: \n
3 - optional, strip and clean data, remove leading trailing whitespace etc

Similar to reader() except this creates an array of data 
by lines from the command arg

----------------------------------------
  CODE
----------------------------------------

@content = main::grabber('lspci -knn',"\n",'strip');

========================================
is_int()
----------------------------------------

Basically is_int, pass it a value, if it is only one  or more digits
return 1, otherwise return undefined.

----------------------------------------
  CODE
----------------------------------------

do something if is_int($value);

========================================
is_numeric()
----------------------------------------

Basic check, contains 1 or more digits or '.', then make 
sure one of the characters after that test is a digit to avoid
things like '.' alone, then check no more than 1 dot.

return 1, otherwise return undefined.

NOTE:
See optimization.txt: SECRET OPERATORS for specifics on method

----------------------------------------
  CODE
----------------------------------------

do something if is_numeric($value);

========================================
joiner()
----------------------------------------

args:
1 - array to join, by ref. NOTE: a reference of an undefined array is NOT undefined!
2 - separator for join action
3 - default value, return this if array is unset or undefined

Gets array ref, which may be undefined, plus join string
This helps avoid debugger print errors when we are printing arrays
which we don't know are defined or not null.

Tests to see if array is unset. Array is passed by reference.

----------------------------------------
  CODE
----------------------------------------

$string = main::joiner(\@data,'; ', 'unset');

========================================
lister()
----------------------------------------

Args:
1. Directory

returns files in directory, null if directory empty.
Removes . and .. files.

----------------------------------------
  CODE
----------------------------------------

@files = main::lister('/sys/modules');

========================================
program_data()
----------------------------------------

This is a wrapper for program_values() and program_version().
Use only if you only need the program print name / version.

arg 3 lets you avoid unnecessary calls to program version, and 
only runs if actual $extra level is >= $level

Returns array of:
0 - program print name 
1 - program version 

args:
1 - value to send program_values()
2 - program running name to send to program_version()
3 - $level. $extra level to run version query at

----------------------------------------
  CODE
----------------------------------------

@data = main::program_data('i3bar','i3bar');

========================================
program_values()
----------------------------------------

Returns array of:
0 - match string; 
1 - search number; [-1] means the last string in the version value matched
2 - version string; 
3 - Print name
4 - console 0/1; 
5 - 0/1 exit version loop at first iteration
6 - 0/1 write to stderr

args: 
1 - program/id lower case name

----------------------------------------
  CODE
----------------------------------------

@data = main::program_values('blackbox');

========================================
program_version()
----------------------------------------

args: 
1 - desktop/app command for --version; 
2 - search string; 
3 - space print number; 
4 - [optional] version arg: -v, version, etc
5 - [optional] 0/1 exit on first find of match
6 - [optional] 0/1 write to stderr

NOTE: if you used check_program, it returns full path, so program_version
doesn't need to search for the path again.

This runs the variant of --version that applies, sets to stderr if output
goes there, which it does for some programs and applications. See logic
for specifics. --version data going to stderr is more common than you might
think!

If this receives a string that does not start with /, it assumes it has 
not been validated, and gets the full path using check_program. If null, 
it returns 0 to calling function, and exits program_version.

----------------------------------------
  CODE
----------------------------------------

$version = main::program_version($path,'^nano',3);

========================================
reader()
----------------------------------------

arg: 
1 - full file path, returns array of file lines.
2 - optional, strip and clean data
3 - optional, return scalar, specific index of array, if index defined in array, 
    otherwise returns undef. undef needs to be remembered, there can be undef, '',
    0 tests in inxi, so make sure you use undefined results correctly....

Note: chomp has to chomp the entire action, not just <$fh>
That's inside this sub routine, not something you do.

Returns array of lines of output.

----------------------------------------
  CODE
----------------------------------------

@data = main::reader($path,'strip');

========================================
regex_range()
----------------------------------------

args: 
1 - a numeric type string to turn into regex range

Samples:
1-5: returns: 1|2|3|4|5
2-4,12-15: returns: 2|3|4|12|13|14|15
2,5: returns 2|5
2,5,12-14: returns: 2|5|12|13|14|15

----------------------------------------
  CODE
----------------------------------------

$range = main::regex_range('1-15,3-4);

========================================
toucher()
----------------------------------------

args: 
1 - the file to create if not exists

Failure is handled by main::error_handler(), and will terminate script execution.

This may require changing in full production pinxi, we'll see, but technically, 
the user who runs pinxi should be running with their user permissions, so the files
should be writable always in their $HOME data.

----------------------------------------
  CODE
----------------------------------------

main::toucher($file_path);

========================================
trimmer()
----------------------------------------

Calling it trimmer to avoid conflicts with existing trim stuff in Perl.

args:
1 - string to be right left trimmed. Also slices off \n so no chomp needed

This thing is super fast, no need to log its times etc, 0.0001 seconds or less

Receives string, returns trimmed string.

----------------------------------------
  CODE
----------------------------------------

$string = main::trimmer($string);

========================================
uniq()
----------------------------------------

Just like shell uniq, returns unique items only.

args:
1 - array ref to return only unique elements of

Send array ref, assign to hash as keys, no return since the reference 
is what is changed.

----------------------------------------
  CODE
----------------------------------------

@data = main::uniq(\@data);

========================================
writer()
----------------------------------------

args: 
1 - file full  path to write to; 
2 - array ref/scalar of data to write. 

Note: turning off strict refs so we can pass it a scalar or an array reference.
That's only done within the scope of writer()

----------------------------------------
  CODE
----------------------------------------

main::writer($full_path, @data);

================================================================================
SPECIFIC TOOLS
--------------------------------------------------------------------------------

These tools are specialized and will only be used under very specific
circumstances.

========================================

----------------------------------------



----------------------------------------
  CODE
----------------------------------------

========================================

----------------------------------------



----------------------------------------
  CODE
----------------------------------------

========================================

----------------------------------------



----------------------------------------
  CODE
----------------------------------------
