================================================================================
INXI CPU
================================================================================
FILE:    inxi-cpu.txt
VERSION: 1.3
DATE:    2022-07-29

----------------------------------------
Docs:
See: inxi-cpu-flags.txt

----------------------------------------
Code:
See:

----------------------------------------
Comments:

================================================================================
Sections:
CPU FUNCTIONS DATA
 CPU Flags
 
CPU DATA
 ARM
  Android
 cpu_sys()
 cp_cpu_arch()
 scaling / cpuinfo speeds
 Cache L1 L2 L3
 Topology
  CPU Dies
 FreeBSD
 DragonFly
 
CPU EXTERNAL DATA
 Early Intel

================================================================================
CPU FUNCTIONS DATA
--------------------------------------------------------------------------------

========================================
CPU Flags
----------------------------------------

See: inxi-cpu-flags.txt for links, -Cx vs -f (short form vs full), and current 
listed flags definitions. Includes overview of the short form flag items 
so it's reasonably clear why those are the short form defaults.

========================================
cp_cpu_arch()
----------------------------------------

AMD CPU MICROARCHITECTURES:
https://en.wikipedia.org/wiki/List_of_AMD_CPU_microarchitectures

# fulll table of support!
https://en.wikipedia.org/wiki/Template:AMD_x86_CPU_features

https://www.techradar.com/news/rumored-problems-at-tsmc-could-delay-the-next-generation-of-amd-cpus

https://www.tomshardware.com/picturestory/735-history-of-amd-graphics-3.html

Intel CPUs
https://en.wikichip.org/wiki/intel#List_of_microarchitectures
https://www.intel.com/content/www/us/en/design/products-and-solutions/processors-and-chipsets/platform-codenames.html
product codes: https://en.wikipedia.org/wiki/List_of_Intel_microprocessors
https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers

https://en.wikipedia.org/wiki/Intel_Core

https://www.hp.com/us-en/shop/tech-takes/intel-processor-guide

# good tables, include cpuid/process!
https://soggi.org/misc/intel-sspec.htm

This is really good:
https://en.wikichip.org/wiki/amd/cpuid
https://en.wikichip.org/wiki/intel/cpuid
combined with cpuinfo from:
https://intel-gfx-ci.01.org/hardware/

Good resource for history, timelines, etc:
https://www.wikiwand.coms
https://www.wikiwand.com/en/I486
https://www.wikiwand.com/en/Pentium_(original)

https://en.wikipedia.org/wiki/List_of_AMD_processors

https://www.hp.com/us-en/shop/tech-takes/intel-processor-guide
https://www.intel.com/content/www/us/en/support/articles/000032203/processors/intel-core-processors.html
https://www.intel.com/content/www/us/en/processors/processor-numbers.html

https://en.wikichip.org/wiki/intel/process_technology
# this is useful, lists process of each name, but note doesn't cover the multi
# gen code names like Comet lake etc.
https://en.wikichip.org/wiki/intel/microarchitectures
https://en.wikichip.org/wiki/intel/microarchitectures/netburst

https://pcgearlab.com/articles/how-to-check-intel-processor-generation/

https://wccftech.com/intel-confirms-next-gen-cpu-gpu-families-raptor-lake-meteor-lake-xe-hpg-dg2-gaming-graphics-cards/

Intel Mainstream CPU Generations Comparison:
Intel CPU Family	Processor Process	Processor Architecture	Processors Cores/Threads (Max)	TDPs	Platform Chipset	Platform	Memory Support	PCIe Support	Launch
Sandy Bridge (2nd Gen)	32nm	Sandy Bridge	4/8	35-95W	6-Series	LGA 1155	DDR3	PCIe Gen 2.0	2011
Ivy Bridge (3rd Gen)	22nm	Ivy Bridge	4/8	35-77W	7-Series	LGA 1155	DDR3	PCIe Gen 3.0	2012
Haswell (4th Gen)	22nm	Haswell	4/8	35-84W	8-Series	LGA 1150	DDR3	PCIe Gen 3.0	2013-2014
Broadwell (5th Gen)	14nm	Broadwell	4/8	65-65W	9-Series	LGA 1150	DDR3	PCIe Gen 3.0	2015
Skylake (6th Gen)	14nm	Skylake	4/8	35-91W	100-Series	LGA 1151	DDR4	PCIe Gen 3.0	2015
Kaby Lake (7th Gen)	14nm	Skylake	4/8	35-91W	200-Series	LGA 1151	DDR4	PCIe Gen 3.0	2017
Coffee Lake (8th Gen)	14nm	Skylake	6/12	35-95W	300-Series	LGA 1151	DDR4	PCIe Gen 3.0	2017
Coffee Lake (9th Gen)	14nm	Skylake	8/16	35-95W	300-Series	LGA 1151	DDR4	PCIe Gen 3.0	2018
Comet Lake (10th Gen)	14nm	Skylake	10/20	35-125W	400-Series	LGA 1200	DDR4	PCIe Gen 3.0	2020
Rocket Lake (11th Gen)	14nm	Cypress Cove	8/16	35-125W	500-Series	LGA 1200	DDR4	PCIe Gen 4.0	2021
Alder Lake (12th Gen)	Intel 7	Golden Cove (P-Core)
Gracemont (E-Core)	16/24	35-125W	600 Series	LGA 1700/1800	DDR5 / DDR4	PCIe Gen 5.0	2021
Raptor Lake (13th Gen)	Intel 7	Raptor Cove (P-Core)
Gracemont (E-Core)	24/32	35-125W	700-Series	LGA 1700/1800	DDR5 / DDR4	PCIe Gen 5.0	2022
Meteor Lake (14th Gen)	Intel 4	Redwood Cove (P-Core)
Crestmont (E-Core)	TBA	35-125W	800 Series?	LGA 1851	DDR5	PCIe Gen 5.0	2023
Arrow Lake (15th Gen)	Intel 20A	Lion Cove (P-Core)
Skymont (E-Core)	40/48	TBA	900-Series?	LGA 1851	DDR5	PCIe Gen 5.0	2024
Lunar Lake (16th Gen)	Intel 18A	TBD	TBA	TBA	1000-Series?	TBA	DDR5	PCIe Gen 5.0?	2025
Nova Lake (17th Gen)	Intel 18A	TBD	TBA	TBA	2000-Series?	TBA	DDR5? PCIe Gen 6.0? 2026

Intel Xeon SP Families (Preliminary):
Family Branding	Skylake-SP	Cascade Lake-SP/AP	Cooper Lake-SP	Ice Lake-SP	Sapphire Rapids	Emerald Rapids	Granite Rapids	Diamond Rapids
Process Node	14nm+	14nm++	14nm++	10nm+	Intel 7	Intel 7	Intel 3	Intel 3?
Platform Name	Intel Purley	Intel Purley	Intel Cedar Island	Intel Whitley	Intel Eagle Stream	Intel Eagle Stream	Intel Mountain Stream
Intel Birch Stream	Intel Mountain Stream
Intel Birch Stream
Core Architecture	Skylake	Cascade Lake	Cascade Lake	Sunny Cove	Golden Cove	Raptor Cove	Redwood Cove?	Lion Cove?
IPC Improvement (Vs Prev Gen)	10%	0%	0%	20%	19%	8%?	35%?	39%?
MCP (Multi-Chip Package) SKUs	No	Yes	No	No	Yes	Yes	TBD (Possibly Yes)	TBD (Possibly Yes)
Socket	LGA 3647	LGA 3647	LGA 4189	LGA 4189	LGA 4677	LGA 4677	TBD	TBD
Max Core Count	Up To 28	Up To 28	Up To 28	Up To 40	Up To 56	Up To 64?	Up To 120?	Up To 144?
Max Thread Count	Up To 56	Up To 56	Up To 56	Up To 80	Up To 112	Up To 128?	Up To 240?	Up To 288?
Max L3 Cache	38.5 MB L3	38.5 MB L3	38.5 MB L3	60 MB L3	105 MB L3	120 MB L3?	240 MB L3?	288 MB L3?
Vector Engines	AVX-512/FMA2	AVX-512/FMA2	AVX-512/FMA2	AVX-512/FMA2	AVX-512/FMA2	AVX-512/FMA2	AVX-1024/FMA3?	AVX-1024/FMA3?
Memory Support	DDR4-2666 6-Channel	DDR4-2933 6-Channel	Up To 6-Channel DDR4-3200	Up To 8-Channel DDR4-3200	Up To 8-Channel DDR5-4800	Up To 8-Channel DDR5-5600?	Up To 12-Channel DDR5-6400?	Up To 12-Channel DDR6-7200?
PCIe Gen Support	PCIe 3.0 (48 Lanes)	PCIe 3.0 (48 Lanes)	PCIe 3.0 (48 Lanes)	PCIe 4.0 (64 Lanes)	PCIe 5.0 (80 lanes)	PCIe 5.0 (80 Lanes)	PCIe 6.0 (128 Lanes)?	PCIe 6.0 (128 Lanes)?
TDP Range (PL1)	140W-205W	165W-205W	150W-250W	105-270W	Up To 350W	Up To 375W?	Up To 400W?	Up To 425W?
3D Xpoint Optane DIMM	N/A	Apache Pass	Barlow Pass	Barlow Pass	Crow Pass	Crow Pass?	Donahue Pass?	Donahue Pass?
Competition	AMD EPYC Naples 14nm	AMD EPYC Rome 7nm	AMD EPYC Rome 7nm	AMD EPYC Milan 7nm+	AMD EPYC Genoa ~5nm	AMD EPYC Bergamo	AMD EPYC Turin	AMD EPYC Venice
Launch	2017	2018	2020	2021	2022	2023? 2024? 2025?

AMD ZEN
https://en.wikipedia.org/wiki/Zen_(first_generation_microarchitecture)
https://en.wikipedia.org/wiki/Zen%2B
https://en.wikipedia.org/wiki/Zen_2
https://en.wikipedia.org/wiki/Zen_3

random data:
https://asteroidsathome.net/boinc/cpu_list.php
has model, family, stepping, but no way to match with familyarch, but otherwise good info
https://www.cpu-world.com/index.html

2014 list, useful for legacy processors, has model, family, and microarch, but isn't always
100% accurate. Prefer en.wikichip.org if there are disagreements
https://a4lg.com/tech/x86/database/x86-families-and-models.en.html

useful info in this one, includes EAX queries and possible values
https://en.wikipedia.org/wiki/CPUID
https://www.felixcloutier.com/x86/cpuid

https://github.com/gcc-mirror/gcc/blob/master/libgcc/config/i386/cpuinfo.c

## Good but not totally reliable list of cpuids, in their raw form:
http://instlatx64.atw.hu/
https://github.com/InstLatx64/InstLatx64

Since sites can vanish, saved cleaned version here: inxi-perl/data/cpu/microarch/instlatx64.txt

----------------------------------------
ELBRUS
----------------------------------------
https://ru-m-wikipedia-org.translate.goog/wiki/%D0%AD%D0%BB%D1%8C%D0%B1%D1%80%D1%83%D1%81_(%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0)?_x_tr_sl=ru&_x_tr_tl=en&_x_tr_hl=ru&_x_tr_pto=wapp)

Due to limited demand, Elbrus processors are produced in small batches on order, 
two sites are used - the Mikron plant in Zelenograd (technological process up to 
90 nm ) and the TSMC factory in Hsinchu, Taiwan . In 2017, it was planned to 
launch the production of Elbrus-4SM, an adapted version of Elbrus-4C for the 
capacities of the Mikron plant, but the company was unable to switch to the 65 
nm process technology required for this.. Due to sanctions against the Russian 
Federation, the production of Russian processors Elbrus and Baikal may have to 
be transferred from a Taiwanese plant to China, this will take one and a half to 
two years, the executive director of the Consortium of Domestic Developers of 
Storage Systems said in an interview with Gazeta.Ru data of RosSHD Oleg 
Izumrudov.

Unlike Intel and AMD , MCST is in the role of catching up, dramatically changing 
the technical process: if in 2014 Elbrus-4C was produced using 65 nm technology, 
then in 2016 the Elbrus-8C production technology is 28 nm. Due to limited 
resources, MCST is focused on the development of a small number of models with a 
release frequency of 2-5 years; the increase in productivity in each generation 
is at the level of 100-500%.

Elbrus-S/E2K/2S+/2SM/4S/8S/8SV/16S russian x86/64 compatible:
https://wikivisually.com/wiki/Elbrus_%28computer%29
https://en.wikipedia.org/wiki/Elbrus-8S
https://wikivisually.com/wiki/Elbrus_2000
https://wikivisually.com/wiki/Elbrus-2S%2B

good tech overview of elbrus specs:
https://www.7-cpu.com/cpu/Elbrus.html

https://en.wikipedia.org/wiki/List_of_Russian_microprocessors

Elbrus 1S+ (SOC+gpu)

----------------------------------------
AMD: Manual, from external, IDs
----------------------------------------

These are from getting the id numbers off the cpu external body:

Note: the shell body often has a year that does not seem related to the release,

like 2001 for a socket 939, which came out 2004.

----------------------------------------

AMD Athlon 
id: A1400AMS3C
shell: 1999

cpu-world:
https://www.cpu-world.com/CPUs/K7/AMD-Athlon%201400%20-%20A1400AMS3C.html

AMD Package number	27016
Socket	Socket A (Socket 462)
Microarchitecture	K7
Processor core  ? 	Thunderbird (Model 4)
Introduction date	6-Jun-01
CPUID	644
Manufacturing process	0.18 micron
37 million transistors
Family:	6 (06h)
Model:	4 (04h)
Stepping:	4 (04h)

----------------------------------------

AMD Athlon 64 3500+
id: ADA3500DEP4AS
shell: na

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%203500%2B%20-%20ADA3500DEP4AS%20(ADA3500ASBOX).html

Socket Socket 939
Introduction date Jun 1, 2004
Price at introduction $500
Microarchitecture K8
Processor core ? ClawHammer
Core stepping ? SH-CG
CPUID F7A
Family: 15 (0Fh)
Model: 7 (07h)
Stepping: 10 (0Ah)

----------------------------------------

AMD Athlon 64 3500+
id: ADA3500DAA4BW
shell: na

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%203500%2B%20-%20ADA3500DAA4BW%20(ADA3500BWBOX).html

Microarchitecture K8
Processor core ? Venice
Core stepping ? DH-E6
CPUID 20FF2
Manufacturing process 0.09 micron silicon-on-insulator (SOI) technology
Data width 64 bit
The number of CPU cores 1
The number of threads 1
Family: 15 (0Fh)
Model: 47 (02Fh)
Stepping: 2 (02h)

----------------------------------------

AMD Sempron 2200+: A1908810
ID: SDA2200DUT3D
shell: 1999

cpu-world:
https://www.cpu-world.com/CPUs/K7/AMD-Sempron%202200%2B%20-%20SDA2200DUT3D%20(SDA2200BOX).html

Thoroughbred
Socket	Socket A (Socket 462)
Introduction date	July 28, 2004 [this has to be wrong]
Microarchitecture	K7
Processor core  ? 	Thoroughbred (Model 8)
CPUID	681
Manufacturing process	0.13 micron
CPUID signature:	681
Family:	6 (06h)
Model:	8 (08h)
Stepping:	1 (01h)

----------------------------------------

AMD Athlon 64 X2
id: ADA3800DAASBV [5BV?]

shell: 2001

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%20X2%203800%2B%20-%20ADA3800DAA5BV%20(ADA3800BVBOX).html

Family	AMD Athlon 64 X2
Microarchitecture	K8
Processor core  ? 	Manchester
Socket	Socket 939
Processor core  ? 	Manchester
Introduction date	Aug 1, 2005
CPUID	20FB1
Manufacturing process	0.09 micron
150 million transistors
Family:	15 (0Fh)
Model:	43 (02Bh)
Stepping:	1 (01h)

----------------------------------------

AMD Athlon 64 X2
id: AD04800IA5DD
shell: 2005

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%20X2%204800%2B%20-%20ADO4800IAA5DD%20(ADO4800DDBOX).html

Family	AMD Athlon 64 X2
Socket	Socket AM2
Introduction date	Dec 5, 2006
Microarchitecture	K8
Platform	Cartwheel
Processor core  ? 	Brisbane
Manufacturing process	0.065 micron silicon-on-insulator (SOI) technology
221 million transistors
Family:	15 (0Fh)
Model:	107 (06Bh)
Stepping:	1 (01h)

----------------------------------------

AMD Athlon 64
id: ADA3200AEP4AX
shell: 2001

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%203200%2B%20-%20ADA3200AEP4AX%20(ADA3200AXBOX).html

Family	AMD Athlon 64
Socket	Socket 754
Microarchitecture	K8
Processor core  ? 	NewCastle
Manufacturing process	0.13 micron silicon-on-insulator (SOI) technology
Intro date: NA
Family:	15 (0Fh)
Model:	12 (0Ch)
Stepping:	0 (00h)

----------------------------------------

AMD Athlon 64 X2
id: ADA3800DAA5CD
shell: 2001

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%20X2%203800%2B%20-%20ADA3800DAA5CD%20(ADA3800CDBOX).html

Family	AMD Athlon 64 X2
Socket	Socket 939
Introduction date	Aug 1, 2005
Microarchitecture	K8
Processor core  ? 	Toledo
CPUID	20F32
Manufacturing process	0.09 micron
150 million transistors
Family:	15 (0Fh)
Model:	35 (023h)
Stepping:	2 (02h)

----------------------------------------

AMD Athlon XP 2000+
package number: 27111
shell: na

cpu-world:
https://www.cpu-world.com/CPUs/K7/AMD-Athlon%20XP%202000+%20-%20AX2000DMT3C.html

Socket	Socket A (Socket 462)
Microarchitecture	K7
Processor core  ? 	Palomino (Model 6)
Manufacturing process	0.18 micron copper process
Family:	6 (06h)
Model:	6 (06h)
Stepping:	2 (02h)

----------------------------------------

# from cpu shell/mobo
AMD Athlon 64 X2
id: ADA3800DAA5BV
socket: 939
shell: 2001

# from cpu-world
see above

----------------------------------------

----------------------------------------

----------------------------------------
Intel: Manual, from external, IDs
----------------------------------------

# from the cpu shell
Intel Celeron
id: FV524RX500
S-Spec: SL3FY
Cache: 128 KB
Shell year: 1998

https://www.cpu-world.com/sspec/SL/SL3FY.html
# from cpu-world
Socket: Socket 370 
Price at introduction: ?
Microarchitecture: Celeron
Processor core: Mendicino
Process: 250 nm
Core stepping: B0
CPUID: 665 (0665h)
Family: 6 (06h)
Model: 6 (06h)
Stepping: 5 (05h)

# from wikipedia.org
https://en.wikipedia.org/wiki/List_of_Intel_Celeron_processors
Introduction date: August 1999

----------------------------------------
cpu microarchitecture levels:
----------------------------------------

Added for inxi 3.3.21, -Cxx, comes after arch:[gen] as level:

Go supports it:
https://utcc.utoronto.ca/~cks/space/blog/programming/GoAmd64ArchitectureLevels

GCC supports it I think via -O [number] option.
https://www.researchgate.net/figure/Behavior-of-versions-v1-v2-and-v3-using-all-nodes-in-CPU-GPU-configuration_fig4_333638943

Explanation:
https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels

Level 	CPU features 	Example instruction
x86-64
(baseline: all x86-64 CPUs) 	CMOV 	cmov
CX8 	cmpxchg8b
FPU 	fld
FXSR 	fxsave
MMX 	emms
OSFXSR 	fxsave
SCE 	syscall
SSE 	cvtss2si
SSE2 	cvtpi2pd

x86-64-v2
(circa 2009: Nehalem and Jaguar)

Also:

    QEMU Emulation
    Atom Silvermont (2013)
    VIA Nano and Eden "C" (2015)

	CMPXCHG16B 	cmpxchg16b
LAHF-SAHF 	lahf
POPCNT 	popcnt
SSE3 	addsubpd
SSE4_1 	blendpd
SSE4_2 	pcmpestri
SSSE3 	phaddd

x86-64-v3
(circa 2015: Haswell and Excavator)

Also:

    Atom Gracemont (2021)

	AVX 	vzeroall
AVX2 	vpermd
BMI1 	andn
BMI2 	bzhi
F16C 	vcvtph2ps
FMA 	vfmadd132pd
LZCNT 	lzcnt
MOVBE 	movbe
OSXSAVE 	xgetbv

x86-64-v4
(AVX-512's general-purpose subset) 	AVX512F 	kmovw
AVX512BW 	vdbpsadbw
AVX512CD 	vplzcntd
AVX512DQ 	vpmullq
AVX512VL 	n/a 

> v2 caveats:
https://lists.opensuse.org/archives/list/users@lists.opensuse.org/message/VZAXMLRKSWSSBU4PD6TDIV4TINJMIZ3E/
Note that detection of v3 and above is unreliable in any case because

1. OSXSAVE flag is not exposed in /proc/cpuinfo at all (inxi checks for
this non-existent flag but as we have seen it ignores lack of it, awk
script checks for XSAVE which is strictly speaking wrong)

2. Not only XSAVE must be enabled (OSXSAVE), it must also support
saving/restoring of processor state for features on this level. This
information is not exposed either, it is printed by kernel on startup

x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'
 x86/fpu: Supporting XSAVE feature 0x002: 'SSE registers'
 x86/fpu: Supporting XSAVE feature 0x004: 'AVX registers'

So any detection based on flags in /proc/cpuinfo is optimistic guess at
most.

[note: this is a raw tex file, which is absurd to pointo to as a resource, which
is probably one reason very few people know about these issues].
"Official" definition of levels is in
https://gitlab.com/x86-psABIs/x86-64-ABI/-/blob/master/x86-64-ABI/low-level-sys-info.tex

========================================
set_cpu_speeds_sys()
----------------------------------------

ARM ODROID CPU SPEEDS:
https://github.com/smxi/inxi/issues/128

========================================
cpu_dmi_data()
----------------------------------------

https://en.wikipedia.org/wiki/CPU_socket

========================================
data_cpuinfo()
----------------------------------------

RYZEN:
https://www.pcworld.com/article/3214635/components-processors/ryzen-threadripper-review-we-test-amds-monster-cpu.html
INTEL:
https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers
https://en.wikipedia.org/wiki/List_of_Intel_microprocessors
https://github.com/pytorch/cpuinfo/blob/master/src/x86/uarch.c
http://www.cpu-world.com/
https://en.wikichip.org/wiki/intel/cpuid

# intel dies etc, pcie, dmi 2.0/3.0
https://www.anandtech.com/show/10303/choosing-the-right-ssd-for-a-skylakeu-system
https://h30434.www3.hp.com/t5/Notebook-Hardware-and-Upgrade-Questions/And-this-is-why-my-960-evo-can-t-get-3200MB-s-on-my-spectre/td-p/5975464

# commit for complex /proc/cpuinfo options
Add Alder Lake support for perf (kernel)
https://lwn.net/Articles/851479/

# lists of datasets
https://intel-gfx-ci.01.org/hardware/

# about Elbrus:
https://www.7-cpu.com/cpu/Elbrus.html

# bogomips from many cpus!
https://tldp.org/HOWTO/BogoMips/bogo-list.html

========================================
cpu_bugs_sys()
----------------------------------------

http://kroah.com/log/blog/2018/01/06/meltdown-status/

https://www.maketecheasier.com/check-linux-meltdown-spectre-vulnerability/

========================================
cpu_sys()
----------------------------------------

https://www.kernel.org/doc/html/v4.14/admin-guide/pm/cpufreq.html
https://www.codeblueprint.co.uk/2019/11/05/does-smt-make-sense.html

Security/SMT
https://www.theregister.com/2019/10/29/intel_disable_hyper_threading_linux_kernel_maintainer/
----------------------------------------
cpu frequencies /proc/cpuinfo
 Bug 197009
Summary: /proc/cpuinfo does not update frequency
https://bugzilla.kernel.org/show_bug.cgi?id=197009

https://bugzilla.kernel.org/show_bug.cgi?id=211791

scaling_cur_freq takes 10ms to read:
https://github.com/htop-dev/htop/issues/471

@KonstantinPlotnikov what is the cpufreq driver on each of these systems?
LANG=C cpufreq-info | grep driver will show.

https://stackoverflow.com/questions/3021054/how-to-read-cpu-frequency-on-android-device
Awesome answer Ellis, you really helped me a lot. One thing that I found in investigating this was that scaling_cur_freq is not necessarily the current CPU frequency, but rather what the kernel thinks the frequency is. To get the real frequency, you need root access to read cpuinfo_cur_freq. Also, gaining root access allows you to set the cpu speed, which is quite useful for profiling under best/worst case conditions. 

time cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq
time cat /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq

There seems to be no standardisation of the /proc/cpuinfo content, see https://manpages.debian.org/unstable/manpages/proc.5.en.html , but reading https://bugzilla.kernel.org/show_bug.cgi?id=197009 it should contain the current CPU frequency.
https://manpages.debian.org/unstable/manpages/proc.5.en.html ,
https://bugzilla.kernel.org/show_bug.cgi?id=197009 

cpuinfo_cur_freq vs scaling_cur_freq
https://github.com/prometheus/procfs/issues/122

 Instantaneous vs. cummulative cpufreq stats #428 
https://github.com/prometheus/procfs/issues/428

https://www.google.com/search?domains=lkml.org&q=scaling_cur_freq&sa=Google+Search&sitesearch=lkml.org&client=pub-3128732077138691&forid=1&ie=UTF-8&oe=UTF-8&flav=0000&sig=IZwGi0IG8Xeqz31p&cof=GALT%3A%23008000%3BGL%3A1%3BDIV%3A%23336699%3BVLC%3A663399%3BAH%3Acenter%3BBGC%3AFFFFFF%3BLBGC%3Adde8e8%3BALC%3A0000FF%3BLC%3A0000FF%3BT%3A000000%3BGFNT%3A0000FF%3BGIMP%3A0000FF%3BFORID%3A1&hl=en

# lkml cpuinfo 
CPU: Always show current CPU frequency in /proc/cpuinfo
https://lkml.org/lkml/2018/1/8/360

To that end, modify the /proc/cpuinfo implementation on x86 to use
aperfmperf_snapshot_khz() to snapshot the APERF and MPERF feedback
registers, if available, and use their values to compute the CPU
frequency to be reported as "cpu MHz".

However, do that carefully enough to avoid accumulating delays that
lead to unacceptable access times for /proc/cpuinfo on systems with
many CPUs.  Run aperfmperf_snapshot_khz() once on all CPUs
asynchronously at the /proc/cpuinfo open time, add a single delay
upfront (if necessary) at that point and simply compute the current
frequency while running show_cpuinfo() for each individual CPU.

Also, to avoid slowing down /proc/cpuinfo accesses too much, reduce
the default delay between consecutive APERF and MPERF reads to 10 ms,
which should be sufficient to get large enough numbers for the
frequency computation in all cases.

----------------------------------------------------

Calculate MHz using APERF/MPERF for cpuinfo and scaling_cur_freq
https://lkml.org/lkml/2016/4/1/7

From: Len Brown <len.brown@intel.com>

For x86 processors with APERF/MPERF and TSC,
return meaningful and consistent MHz in
/proc/cpuinfo and
/sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq

MHz is computed like so:

MHz = base_MHz * delta_APERF / delta_MPERF

MHz is the average frequency of the busy processor
over a measurement interval.  The interval is
defined to be the time between successive reads
of the frequency on that processor, whether from
/proc/cpuinfo or from sysfs cpufreq/scaling_cur_freq.
As with previous methods of calculating MHz,
idle time is excluded.

base_MHz above is from TSC calibration global "cpu_khz".

This x86 native method to calculate MHz returns a meaningful result
no matter if P-states are controlled by hardware or firmware
and/or the Linux cpufreq sub-system is/is-not installed.

Note that frequent or concurrent reads of /proc/cpuinfo
or sysfs cpufreq/scaling_cur_freq will shorten the
measurement interval seen by each reader.  The code
mitigates that issue by caching results for 100ms.

Discerning users are encouraged to take advantage of
the turbostat(8) utility, which can gracefully handle
concurrent measurement intervals of arbitrary length.

================================================================================
CPU DATA
--------------------------------------------------------------------------------

========================================
ARM
----------------------------------------

https://unix.stackexchange.com/questions/255558/understanding-the-output-of-proc-cpuinfo
explanation of the various lines in /proc/cpuinfo

eg:
$ cat /proc/cpuinfo
Processor : AArch64 Processor rev 3 (aarch64)
processor : 0
processor : 1
processor : 2
processor : 3
processor : 4
processor : 5
processor : 6
processor : 7
Features : fp asimd evtstrm aes pmull sha1 sha2 crc32
CPU implementer : 0x41
CPU architecture: AArch64
CPU variant : 0x0
CPU part    : 0xd03
CPU revision    : 3

Hardware : HiKey Development Board

----------
This is the expected output to Arm based processors. All Serialized cores are shown in list with line breaks instead of separated processors. Features are evaluated by cpuinfo code, and only show if all cores support them


    CPU implementer: Your code means ARM;
    CPU architecture: AArch64 means 64 bit ARM board:
    CPU variant : Indicates the variant number of the processor, or "major revision". Yours is zero.
    CPU part: Part number. 0xd03 indicates Cortex-A53 processor.
    CPU revision: Indicates patch release or "minor revision". 3, in your case
    Hardware    : HiKey Development Board is self explanatory

----------------------------------------
Android
----------------------------------------
https://stackoverflow.com/questions/20775982/how-to-understand-the-information-of-my-android-processor

Processor : ARMv7 Processor rev 1 (v7l)
processor : 0
BogoMIPS : 212.33

processor : 1
BogoMIPS : 212.33

Features : swp half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpv4
CPU implementer : 0x41
CPU architecture: 7
CPU variant : 0x0
CPU part    : 0xc05
CPU revision    : 1   
Hardware : MSM8x25 U8951 BOARD
Revision : 0000
Serial : 0000000000000000

========================================
cp_cpu_arch()
----------------------------------------
https://www.hp.com/us-en/shop/tech-takes/intel-processor-guide
Intel Core processors, ranked by generation:

8th Generation, released 2017 to 2019; Coffee Lake, Kaby Lake, Whisky Lake
9th Generation, released 2018 to 2019; Coffee Lake Refresh (Desktop)
10th Generation, released 2019 to 2020; Comet Lake (Desktop), Ice Lake (Mobile)
11th Generation, released 2020 to 2021; Rocket Lake (Desktop, Comet Lake Refresh (Desktop), Tiger Lake (Mobile)

Intel Xeon processor generations:

Cooper Lake, 2020 to 2021; Xeon Gold, Xeon Platinum
Comet Lake, 2020 to 2021; Xeon W
Cascade lake, 2019 to 2020; Xeon Platinum, Xeon Gold, Xeon Silver, Xeon Bronze
Coffee Lake, 2018 to 2019; Xeon E

Intel Pentium processor generations:
Jasper Lake, 2021; Pentium Silver
Comet Lake, 2019 to 2020; Pentium Gold
Tiger Lake (Mobile), 2019 to 2020; Pentium Gold
Coffee Lake, 2018 to 2019; Pentium Gold

Intel Celeron processor generations
Jasper Lake, 2021; Celeron N
Comet Lake, 2019 to 2020; Celeron G5
Tiger Lake (Mobile), 2019 to 2020; Celeron 6305
Coffee Lake, 2018 to 2019; Celeron G4

https://www.intel.com/content/www/us/en/processors/processor-numbers.html

https://en.wikipedia.org/wiki/Intel_Core

https://www.pagetable.com/?p=18

How Itanium messed up Intel’s CPUID family IDs
2006-07-26 by Michael Steil	

Assigning internal version/family/model IDs to products is a non-trivial task, 
especially if there are several different families/architectures on your 
roadmap, and if the marketing names and target markets have no real correlation 
to the internal architecture.

At Intel, everything went wrong. On every modern x86 processor, the CPUID 
instruction returns, among other things, the family code of the CPU. The i486 
(1989) is family 4, Pentium (1993) and Pentium MMX (1997) are family 5, Pentium 
Pro (1995), Pentium 2 (1997), Pentium 3 (2000) and Pentium M (2003) are family 6 
(“P6 microarchitecture”).

https://blog.codinghorror.com/

# fulll table of support!
https://en.wikipedia.org/wiki/Template:AMD_x86_CPU_features
https://en.wikipedia.org/wiki/Athlon#Athlon_Thunderbird_(2000-2001)

https://www.reddit.com/r/Amd/comments/7rk6u2/when_and_why_did_amd_switch_from_tsmc_to_glofo/

https://www.notebookcheck.net/Intel-details-new-process-innovations-and-node-names-Alder-Lake-10-nm-Enhanced-SuperFin-is-now-Intel-7-Intel-20A-is-the-2-nm-process-for-2024.552398.0.html

Intel feels the numbers denoted to indicate a process node are "just numbers" 
and that there is an inherent inconsistency in the current naming scheme. 
Therefore, the company will no longer indicate the process node in terms of 
nanometers but will use a new numbering scheme as follows:

Intel 7: This is the new name for 10 nm Enhanced SuperFin process and will 
feature in Alder Lake (client, 2021) and Sapphire Rapids (datacenter, Q1 2022) 
processor families. Intel 7 is slated to offer a 10% to 15% performance increase 
over the current 10 nm SuperFin process. 

Intel 4: This is Intel's actual 7 nm part that uses extreme ultraviolet (EUV) 
lithography with an estimated 20% increase in performance-per-watt. Intel 4 will 
feature in products such as Meteor Lake (client) and Granite Rapids (datacenter) 
for production in 2H 2022 and shipping in 2023. The ultra-short EUV wavelength 
enables Intel to offer features such as 192 execution units (EUs) in Meteor 
Lake's iGPU and significantly enhanced core counts (up to 120?) for a dual-die 
Granite Rapids processor.

Intel 3: Intel 3 will see the final, maximum leverage of FinFET optimizations. 
FinFET first debuted with 22 nm Ivy Bridge processors back in 2011 and has since 
come a long way. Intel 3 uses increased EUV for an approximately 18% 
performance-per-watt increase over Intel 4 along with additional area 
improvements. Intel 3 will begin manufacturing in 2H 2023. 

Intel 20A: With Intel 20A, we are officially entering into the Angstrom era (10 
Angstrom = 1 nm). Intel 20A will see the introduction of a new transistor 
architecture named RibbonFET for faster transistor switching while achieving the 
same drive current in a smaller footprint. Debuting alongside RibbonFET is 
PowerVia, the company's first implementation of a backside power delivery 
mechanism that negates the need for power routing on the front of the wafer.

Intel 20A will ramp up in 2024 with Qualcomm expected to be one of the partners 
that will leverage this process node.

Intel 18A and beyond: Intel said that Intel 18A is already in development for 
early 2025. Intel 18A will use further refinements in RibbonFET and will be 
among the first to receive and deploy high numerical aperture (NA) EUV 
lithography in collaboration with lithography giant ASML. 

========================================
cpu_sys()
----------------------------------------
https://www.kernel.org/doc/html/v4.14/admin-guide/pm/cpufreq.html

Policy Interface in sysfs

During the initialization of the kernel, the CPUFreq core creates a sysfs 
directory (kobject) called cpufreq under /sys/devices/system/cpu/.

That directory contains a policyX subdirectory (where X represents an integer 
number) for every policy object maintained by the CPUFreq core. Each policyX 
directory is pointed to by cpufreq symbolic links under 
/sys/devices/system/cpu/cpuY/ (where Y represents an integer that may be 
different from the one represented by X) for all of the CPUs associated with (or 
belonging to) the given policy. The policyX directories in 
/sys/devices/system/cpu/cpufreq each contain policy-specific attributes (files) 
to control CPUFreq behavior for the corresponding policy objects (that is, for 
all of the CPUs associated with them).

Some of those attributes are generic. They are created by the CPUFreq core and 
their behavior generally does not depend on what scaling driver is in use and 
what scaling governor is attached to the given policy. Some scaling drivers also 
add driver-specific attributes to the policy directories in sysfs to control 
policy-specific aspects of driver behavior.

The generic attributes under /sys/devices/system/cpu/cpufreq/policyX/ are the 
following:

affected_cpus
    List of online CPUs belonging to this policy (i.e. sharing the hardware performance scaling interface represented by the policyX policy object).
bios_limit

    If the platform firmware (BIOS) tells the OS to apply an upper limit to CPU frequencies, that limit will be reported through this attribute (if present).

    The existence of the limit may be a result of some (often unintentional) BIOS settings, restrictions coming from a service processor or another BIOS/HW-based mechanisms.

    This does not cover ACPI thermal limitations which can be discovered through a generic thermal driver.

    This attribute is not present if the scaling driver in use does not support it.
cpuinfo_cur_freq

    Current frequency of the CPUs belonging to this policy as obtained from the hardware (in KHz).

    This is expected to be the frequency the hardware actually runs at. If that frequency cannot be determined, this attribute should not be present.
cpuinfo_max_freq
    Maximum possible operating frequency the CPUs belonging to this policy can run at (in kHz).
cpuinfo_min_freq
    Minimum possible operating frequency the CPUs belonging to this policy can run at (in kHz).
cpuinfo_transition_latency

    The time it takes to switch the CPUs belonging to this policy from one P-state to another, in nanoseconds.

    If unknown or if known to be so high that the scaling driver does not work with the ondemand governor, -1 (CPUFREQ_ETERNAL) will be returned by reads from this attribute.
related_cpus
    List of all (online and offline) CPUs belonging to this policy.
scaling_available_governors

    List of CPUFreq scaling governors present in the kernel that can be attached to this policy or (if the intel_pstate scaling driver is in use) list of scaling algorithms provided by the driver that can be applied to this policy.

    [Note that some governors are modular and it may be necessary to load a kernel module for the governor held by it to become available and be listed by this attribute.]
scaling_cur_freq

    Current frequency of all of the CPUs belonging to this policy (in kHz).

    In the majority of cases, this is the frequency of the last P-state requested by the scaling driver from the hardware using the scaling interface provided by it, which may or may not reflect the frequency the CPU is actually running at (due to hardware design and other limitations).

    Some architectures (e.g. x86) may attempt to provide information more precisely reflecting the current CPU frequency through this attribute, but that still may not be the exact current CPU frequency as seen by the hardware at the moment.
scaling_driver
    The scaling driver currently in use.
scaling_governor

    The scaling governor currently attached to this policy or (if the intel_pstate scaling driver is in use) the scaling algorithm provided by the driver that is currently applied to this policy.

    This attribute is read-write and writing to it will cause a new scaling governor to be attached to this policy or a new scaling algorithm provided by the scaling driver to be applied to it (in the intel_pstate case), as indicated by the string written to this attribute (which must be one of the names listed by the scaling_available_governors attribute described above).
scaling_max_freq

    Maximum frequency the CPUs belonging to this policy are allowed to be running at (in kHz).

    This attribute is read-write and writing a string representing an integer to it will cause a new limit to be set (it must not be lower than the value of the scaling_min_freq attribute).
scaling_min_freq

    Minimum frequency the CPUs belonging to this policy are allowed to be running at (in kHz).

    This attribute is read-write and writing a string representing a non-negative integer to it will cause a new limit to be set (it must not be higher than the value of the scaling_max_freq attribute).
scaling_setspeed

    This attribute is functional only if the userspace scaling governor is attached to the given policy.

    It returns the last frequency requested by the governor (in kHz) or can be written to in order to set a new frequency for the policy.


The boost File in sysfs

This file is located under /sys/devices/system/cpu/cpufreq/ and controls the 
“boost” setting for the whole system. It is not present if the underlying 
scaling driver does not support the frequency boost mechanism (or supports it, 
but provides a driver-specific interface for controlling it, like intel_pstate).

If the value in this file is 1, the frequency boost mechanism is enabled. This 
means that either the hardware can be put into states in which it is able to 
trigger boosting (in the hardware-based case), or the software is allowed to 
trigger boosting (in the software-based case). It does not mean that boosting is 
actually in use at the moment on any CPUs in the system. It only means a 
permission to use the frequency boost mechanism (which still may never be used 
for other reasons).

If the value in this file is 0, the frequency boost mechanism is disabled and 
cannot be used at all.

The only values that can be written to this file are 0 and 1.


Legacy AMD cpb Knob

The AMD powernow-k8 scaling driver supports a sysfs knob very similar to the 
global boost one. It is used for disabling/enabling the “Core Performance Boost” 
feature of some AMD processors.

If present, that knob is located in every CPUFreq policy directory in sysfs 
(/sys/devices/system/cpu/cpufreq/policyX/) and is called cpb, which indicates a 
more fine grained control interface. The actual implementation, however, works 
on the system-wide basis and setting that knob for one policy causes the same 
value of it to be set for all of the other policies at the same time.

That knob is still supported on AMD processors that support its underlying 
hardware feature, but it may be configured out of the kernel (via the 
CONFIG_X86_ACPI_CPUFREQ_CPB configuration option) and the global boost knob is 
present regardless. Thus it is always possible use the boost knob instead of the 
cpb one which is highly recommended, as that is more consistent with what all of 
the other systems do (and the cpb knob may not be supported any more in the 
future).

The cpb knob is never present for any processors without the underlying hardware 
feature (e.g. all Intel ones), even if the CONFIG_X86_ACPI_CPUFREQ_CPB 
configuration option is set.

https://lwn.net/Articles/254445/ legacy cpu_map in /sys cpu data. If it's legacy 
you can tell either by presence of cpu_map file or by value of files.

/sys/devices/system/cpu/cpu0/cache/index2/shared_cpu_map:["01"]

/sys/devices/system/cpu/cpu0/topology/core_siblings:["01"]
/sys/devices/system/cpu/cpu0/topology/thread_siblings:["01"]
/sys/devices/system/cpu/cpu0/topology/core_id:["0"]

 For a four-socket, dual-core Opteron machine the cache information looks like Table 5.2:

    	type	level	shared_cpu_map
    cpu0 	index0	Data	1	00000001
					index1	Instruction	1	00000001
					index2	Unified	2	00000001
    cpu1 	index0	Data	1	00000002
					index1	Instruction	1	00000002
					index2	Unified	2	00000002
    cpu2 	index0	Data	1	00000004
					index1	Instruction	1	00000004
					index2	Unified	2	00000004
    cpu3 	index0	Data	1	00000008
					index1	Instruction	1	00000008
					index2	Unified	2	00000008
    cpu4 	index0	Data	1	00000010
					index1	Instruction	1	00000010
					index2	Unified	2	00000010
    cpu5 	index0	Data	1	00000020
					index1	Instruction	1	00000020
					index2	Unified	2	00000020
    cpu6 	index0	Data	1	00000040
					index1	Instruction	1	00000040
					index2	Unified	2	00000040
    cpu7 	index0	Data	1	00000080
					index1	Instruction	1	00000080
					index2	Unified	2	00000080
    
 Table 5.3 shows the interesting files in this hierarchy for the SMP Opteron machine.

    	physical_
    package_id 	core_id 	core_
    siblings 	thread_
    siblings
    cpu0	0	0	00000003	00000001
    cpu1 	1	00000003	00000002
    cpu2	1	0	0000000c	00000004
    cpu3 	1	0000000c	00000008
    cpu4	2	0	00000030	00000010
    cpu5 	1	00000030	00000020
    cpu6	3	0	000000c0	00000040
    cpu7 	1	000000c0	00000080
    
Taking Table 5.2 and Table 5.3 together we can see that no CPU has hyper-threads 
(the thread_siblings bitmaps have one bit set), that the system in fact has four 
processors (physical_package_id 0 to 3), that each processor has t

https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-devices-system-cpu

========================================
scaling / cpuinfo speeds
----------------------------------------
https://unix.stackexchange.com/questions/87522/why-do-cpuinfo-cur-freq-and-proc-
cpuinfo-report-different-numbers

So what about cpuinfo_cur_freq?

This parameter has more to do with the specification of the CPU and which 
profile it's currently in, rather than anything useful with respect to how the 
CPU is currently operating. For actual operational telemetry I'd use the 
scaling_* kernel tunables.

----------------------------------------
https://askubuntu.com/questions/1318432/cpufreq-is-missing-from-sys-devices-system-cpu-cpu0
note: in some cases, /sys/devices/system/cpu/cpu0/cpufreq does not exist, maybe
if scaling driver missing, don't know.

----------------------------------------
https://android.googlesource.com/kernel/common/+/a7827a2a60218b25f222b54f77ed38f57aebe08b/Documentation/cpu-freq/user-guide.txt

3.1 Preferred Interface: sysfs
------------------------------
The preferred interface is located in the sysfs filesystem. If you
mounted it at /sys, the cpufreq interface is located in a subdirectory
"cpufreq" within the cpu-device directory
(e.g. /sys/devices/system/cpu/cpu0/cpufreq/ for the first CPU).
cpuinfo_min_freq :		this file shows the minimum operating
				frequency the processor can run at(in kHz) 
cpuinfo_max_freq :		this file shows the maximum operating
				frequency the processor can run at(in kHz) 
cpuinfo_transition_latency The time it takes on this CPU to
				switch between two frequencies in nano
				seconds. If unknown or known to be
				that high that the driver does not
				work with the ondemand governor, -1
				(CPUFREQ_ETERNAL) will be returned.
				Using this information can be useful
				to choose an appropriate polling
				frequency for a kernel governor or
				userspace daemon. Make sure to not
				switch the frequency too often
				resulting in performance loss.
scaling_driver :		this file shows what cpufreq driver is
				used to set the frequency on this CPU
scaling_available_governors :	this file shows the CPUfreq governors
				available in this kernel. You can see the
				currently activated governor in
scaling_governor, and by "echoing" the name of another
				governor you can change it. Please note
				that some governors won't load - they only
				work on some specific architectures or
				processors.
cpuinfo_cur_freq :		Current frequency of the CPU as obtained from
				the hardware, in KHz. This is the frequency
				the CPU actually runs at.
scaling_available_frequencies : List of available frequencies, in KHz.
scaling_min_freq and
scaling_max_freq show the current "policy limits" (in
				kHz). By echoing new values into these
				files, you can change these limits.
				NOTE: when setting a policy you need to
				first set scaling_max_freq, then
				scaling_min_freq.
affected_cpus :			List of CPUs that require software coordination
				of frequency.
related_cpus :			List of CPUs that need some sort of frequency
				coordination, whether software or hardware.
scaling_driver :		Hardware driver for cpufreq.
scaling_cur_freq :		Current frequency of the CPU as determined by
				the governor and cpufreq core, in KHz. This is
				the frequency the kernel thinks the CPU runs
				at.
bios_limit :			If the BIOS tells the OS to limit a CPU to
				lower frequencies, the user can read out the
				maximum available frequency from this file.
				This typically can happen through (often not
				intended) BIOS settings, restrictions
				triggered through a service processor or other
				BIOS/HW based implementations.
				This does not cover thermal ACPI limitations
				which can be detected through the generic
				thermal driver.
If you have selected the "userspace" governor which allows you to
set the CPU operating frequency to a specific value, you can read out
the current frequency in
scaling_setspeed. By "echoing" a new frequency into this
				you can change the speed of the CPU,
				but only within the limits of
				scaling_min_freq and scaling_max_freq.

========================================
Cache L1 L2 L3
----------------------------------------
https://techgearoid.com/articles/does-each-core-have-its-own-l1-and-l2-cache/

While most modern processors do have L1, L2, L3, and even L4 in more recent
ones, there are a few exceptions. Processors With L2 Cache SHARED

There most certainly are/were processors that have L1 cache per each core but
have a shared L2 cache.

The older Core 2 Duo, Pentium Dual Core and the lot had shared L2 cache.

The newer Enterprise and Server Level processors also share L2 cache between
their cores. The 2nd Generation Intel Xeon Phi (Knights Landing) are examples of
processors where L2 cache is shared.

https://community.intel.com/t5/Intel-Moderncode-for-Parallel/How-to-discover-which-caches-L1-L2-L3-are-shared-by-which-HW/td-p/874330


https://stackoverflow.com/questions/944966/how-are-cache-memories-shared-in-multicore-intel-cpus

good graph/charts of intel core architectures
https://www.realworldtech.com/sandy-bridge/2/

https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html

========================================
Topology
----------------------------------------

https://www.spinics.net/lists/linux-tip-commits/msg48756.html

topology: Create core_cpus and die_cpus sysfs attributes

Create CPU topology sysfs attributes: "core_cpus" and "core_cpus_list"

These attributes represent all of the logical CPUs that share the
same core.

These attriutes is synonymous with the existing "thread_siblings" and
"thread_siblings_list" attribute, which will be deprecated.

Create CPU topology sysfs attributes: "die_cpus" and "die_cpus_list".
These attributes represent all of the logical CPUs that share the
same die.

-thread_siblings:
+core_cpus:
 -	internal kernel map of cpuX's hardware threads within the same
- core as cpuX.
+ internal kernel map of CPUs within the same core.
+ (deprecated name: "thread_siblings")

-thread_siblings_list:
+core_cpus_list:
- human-readable list of cpuX's hardware threads within the same
- core as cpuX.
+ human-readable list of CPUs within the same core.
+ (deprecated name: "thread_siblings_list");

+die_cpus:
+
+ internal kernel map of CPUs within the same die.
+
+die_cpus_list:
+
+ human-readable list of CPUs within the same die.
+

----------------------------------------
CPU Dies
----------------------------------------

https://listman.redhat.com/archives/libvir-list/2020-January/msg00277.html

Latest generation CPUs (CascadeLake-AP) support a new topology level known as a 
'die sitting between a socket and a core.

QEMU supports this with -smp arg since 4.1.0

Linux can report this via /sys/devices/system/cpu/cpuNNN/topology via 'die_id' 
and 'die_cpus' and 'die_cpus_list' files since 5.2

This series adds support for <topology> in guest XML to have a new dies' 
parameter, passed to QEMU, which defaults to '1' if omitted.

It extends host capabilities so that NUMA topology reports a new die_id' 
attribute

We can't expand 'virNodeInfoPtr' struct to have a die field, so this will remain 
forever reporting 'cores' as being 'dies * cores'.

The <topology> in host capabilities XML is an interesting question.

If we are strict with our API semantics we would *not* add a 'dies' parameter 
with any value other than '1' to <topology> in the host capabilities. If we 
reported a value other than 1, then any existing apps which multiple  
sockets*cores*threads will get the wrong total CPU count.

We already know <topology> is broken by design for asymetric hardware, so we 
could simply document that it will forever be broken wrt to CPU dies too.  In 
this case we might be better to not even report 'dies=1 just leave out the attr 
entirely.

Interestingly though, <topology> is already more broken than it should be. For a 
VM with   -smp 12,sockets=2,dies=3,cores=2,threads=1 it is reporting <topology 
sockets=1 dies=1 cores=12 threads=1>. It should at least do  <topology sockets=2 
dies=1 cores=6 threads=1>.

I suspect the presence of dies is confusing the really incredibly horrible logic 
in virHostCPUGetInfoLinux. This will also impact virNodeInfoPtr data.

So even if we don't report dies, I think we still have a bug that needs fixing 
here for the coarse node topology.

I'm also confused about what I see with EPYC. IIUC, it was supposed to use the 
'dies' concept, but in machines I've tested, Linux never reports die count other 
than 1.  Perhaps only certain EPYC CPU models or generations use 'dies or 
perhaps Linux isn't reporting correctly for EPYC, or perhaps I'm mislead into 
believeing it uses dies.

Anyway, the upshot is I've not found any real hardware to test this series on. 
I've tested it only inside a QEMU guest with the suitable -smp arg to fake dies.

Daniel P. Berrangé (5):

========================================
FreeBSD:
----------------------------------------

kern.sched.topology_spec:<groups>
 <group level="1" cache-level="0">
  <cpu count="8" mask="ff">0, 1, 2, 3, 4, 5, 6, 7</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="8" mask="ff">0, 1, 2, 3, 4, 5, 6, 7</cpu>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
kern.sched.topology_spec: <groups>
 <group level="1" cache-level="0">
  <cpu count="4" mask="f">0, 1, 2, 3</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="4" mask="f">0, 1, 2, 3</cpu>
    <children>
     <group level="3" cache-level="1">
      <cpu count="2" mask="3">0, 1</cpu>
      <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
     </group>
     <group level="3" cache-level="1">
      <cpu count="2" mask="c">2, 3</cpu>
      <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
     </group>
    </children>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
2x 6 core xeon:

kern.sched.topology_spec: <groups>
 <group level="1" cache-level="0">
  <cpu count="12" mask="fff,0,0,0">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</cpu>
  <children>
   <group level="2" cache-level="3">
    <cpu count="6" mask="3f,0,0,0">0, 1, 2, 3, 4, 5</cpu>
    <children>
     <group level="3" cache-level="2">
      <cpu count="1" mask="1,0,0,0">0</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="2,0,0,0">1</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="4,0,0,0">2</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="8,0,0,0">3</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="10,0,0,0">4</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="20,0,0,0">5</cpu>
     </group>
    </children>
   </group>
   <group level="2" cache-level="3">
    <cpu count="6" mask="fc0,0,0,0">6, 7, 8, 9, 10, 11</cpu>
    <children>
     <group level="3" cache-level="2">
      <cpu count="1" mask="40,0,0,0">6</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="80,0,0,0">7</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="100,0,0,0">8</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="200,0,0,0">9</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="400,0,0,0">10</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="800,0,0,0">11</cpu>
     </group>
    </children>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
inxi-BSD-freebsd-ThinkBSD-2020-09:
 Info: Quad Core model: Intel Core i5-3230M 

kern.smp.topology: 0
kern.smp.cpus: 4
kern.smp.disabled: 0
kern.smp.active: 1
kern.smp.maxcpus: 256
kern.smp.maxid: 3
...
kern.sched.topology_spec: <groups>
 <group level="1" cache-level="3">
  <cpu count="4" mask="f,0,0,0">0, 1, 2, 3</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="2" mask="3,0,0,0">0, 1</cpu>
    <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
   </group>
   <group level="2" cache-level="2">
    <cpu count="2" mask="c,0,0,0">2, 3</cpu>
    <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
   </group>
  </children>
 </group>
</groups>
----------------------------------------
inxi-BSD-freebsd-TinyBSD-2020-09
 Info: Dual Core model: Intel Atom N270 
 
kern.smp.forward_signal_enabled: 1
kern.smp.topology: 0
kern.smp.cpus: 2
kern.smp.disabled: 0
kern.smp.active: 1
kern.smp.maxcpus: 32
kern.smp.maxid: 1

kern.sched.topology_spec: <groups>
 <group level="1" cache-level="2">
  <cpu count="2" mask="3">0, 1</cpu>
  <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
 </group>
</groups>
----------------------------------------
inxi-bsd-rianav.bsd.cdm-201405
FreeBSD 10.0-STABLE

CPU: core AMD Athlon II X2 245 ()

kern.sched.topology_spec: <groups>
 <group level="1" cache-level="0">
  <cpu count="2" mask="3">0, 1</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="2" mask="3">0, 1</cpu>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
inxi-bsd-itwjyg.local-201405
Dual core Intel Core2 Duo P8600 (SMP) cache: 3145.73

Distro: Mac OS X 10.9.2 ... lol...

========================================
DRAGONFLY:
----------------------------------------
inxi-bsd-dflybsd.local-201409

hw.cpu_topology.tree:
\-PACKAGE MEMBERS: cpu0 cpu1
  \-CHIP ID 0: cpu0 cpu1 
    |-CORE ID 0: cpu0 
    \-CORE ID 1: cpu1 

hw.cpu_topology.level_description: 0 - core; 1 - socket; 2 - anything
hw.cpu_topology.members: cpu0 cpu1
hw.cpu_topology.cpu0.physical_id: 0
hw.cpu_topology.cpu0.physical_siblings: cpu0 cpu1
hw.cpu_topology.cpu0.core_id: 0
hw.cpu_topology.cpu0.core_siblings: cpu0
hw.cpu_topology.cpu1.physical_id: 0
hw.cpu_topology.cpu1.physical_siblings: cpu0 cpu1
hw.cpu_topology.cpu1.core_id: 1
hw.cpu_topology.cpu1.core_siblings: cpu1
----------------------------------------
hw.cpu_topology.tree:
\-PACKAGE MEMBERS: cpus(0-1)
  \-CHIP ID 0: cpus(0-1) 
    \-CORE ID 0: cpus(0-1) 
      |-THREAD ID 0: cpus(0-0) 
      \-THREAD ID 1: cpus(1-1) 

hw.cpu_topology.level_description: 0 - thread; 1 - core; 2 - socket; 3 - anything
hw.cpu_topology.members: cpus(0-1)
hw.cpu_topology.cpu0.physical_id: 0
hw.cpu_topology.cpu0.physical_siblings: cpus(0-1)
hw.cpu_topology.cpu0.core_id: 0
hw.cpu_topology.cpu0.core_siblings: cpus(0-1)
hw.cpu_topology.cpu1.physical_id: 0
hw.cpu_topology.cpu1.physical_siblings: cpus(0-1)
hw.cpu_topology.cpu1.core_id: 0
hw.cpu_topology.cpu1.core_siblings: cpus(0-1)

================================================================================
CPU EXTERNAL DATA
--------------------------------------------------------------------------------

The following are taken from web pages, and since you never know when a web page
will vanish, I'm putting copies of the data here, but all copyright belongs to
the original author creator. 

Note that I have never viewed raw data as a copywriteable item, not like a 
creative work, code, etc, it's just data, but I do want to give total credit to
the people and sites that assemble this data, since it's a pain to do it, lol, 
believe me, doing inxi has taught me that.

========================================
Early Intel
----------------------------------------

copyright © soggi 2001-2020

https://soggi.org/misc/intel-sspec.htm#C2

This is a list of some of the data useful for advanced cpu arch, like process/
cpuid matches. Useful mainly because it's so hard to find data of this type for
early generations of cpus.

Note that CPUID did not exist as a standard tool until i486 intel.

----------------------------------------
Data Table
----------------------------------------

i186
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
R80186-3 		- 		3 MHz 	3 MHz 	? nm 	CLCC 	CLCC68 	S40137

i286
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
CG80286-6 C 		- 		6 MHz 	6 MHz 	1500 nm 	CPGA 	PGA68 	S54036
A80286-8 		- 		8 MHz 	8 MHz 	1500 nm 			

i386 DX / i386 SX
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
A80386-16 		- 		16 MHz 	16 MHz 	1500 nm 	CPGA 	PGA132 	S40344
A80386DX-20 		- 		20 MHz 	20 MHz 	1000 nm 	CPGA 	PGA132 	SX217
A80386DX-25 		- 		25 MHz 	25 MHz 	1000 nm 	CPGA 	PGA132 	SX218
A80386DX-33 		- 		33 MHz 	33 MHz 	1000 nm 	CPGA 	PGA132 	SX219
A80386DX-33 		- 		33 MHz 	33 MHz 	1000 nm 	CPGA 	PGA132 	SX366

i486 DX / i486 DX2 / i486 DX4 / i486 SX / i486 SX2
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
A80486SX-25 	P23 	0422h 		25 MHz 	25 MHz 	1000 nm 	CPGA 		SX679
A80486SX-25 	P23 	0423h 		25 MHz 	25 MHz 	1000 nm 	CPGA 		SX798
A80486SX-33 	P23 	042Ah 		33 MHz 	33 MHz 	1000 nm 	CPGA 		SX789
A80486SX-33 	P23 	0423h 		33 MHz 	33 MHz 	1000 nm 	CPGA 		SX797
A80486DX-33 	P4 	0404h 		33 MHz 	33 MHz 	1000 nm 	CPGA 		SX419
SX668
SX729
A80486DX-50 	P4 	0411h 		50 MHz 	50 MHz 	1000 nm 	CPGA 		SX546
A80486DX-50 	P4 	0413h 		50 MHz 	50 MHz 	1000 nm 	CPGA 		SX710
A80486DX2-66 	P24 	0433h 		66 MHz 	33 MHz 	800 nm 	CPGA 		SX645
SX750
A80486DX2-66 	P24 	0435h 		66 MHz 	33 MHz 	800 nm 	CPGA 		SX807
SX911
A80486DX2-66 	P24D 	0436h 		66 MHz 	33 MHz 	800 nm 	CPGA 		SX955
A80486DX4-100 	P24C 	0480h 		100 MHz 	33 MHz 	600 nm 	CPGA 		SK051
SX900
DX2ODPR66 	P23T 	0435h 		66 MHz 	33 MHz 	800 nm 	CPGA 		SZ904

Pentium / Pentium MMX
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
A80501-60 	P5 	0515h 	C1 	60 MHz 	60 MHz 	800 nm 	CPGA-GC 	Socket 4 	SX835
SZ949
A80501-60 	P5 	0517h 	D1 	60 MHz 	60 MHz 	800 nm 	CPGA-GC 	Socket 4 	SX948
A80501-66 	P5 	0515h 	C1 	66 MHz 	66 MHz 	800 nm 	CPGA-GC 	Socket 4 	SX837
A80502-75 	P54C 	0525h 	C2 	75 MHz 	50 MHz 	600 nm 	CPGA 	Socket 5/7 	SX969
A8050275
A8050275 	P54C 	0526h 	E0 	75 MHz 	50 MHz 	600 nm 	CPGA 	Socket 5/7 	SY005
A80502-90 	P54C 	0524h 	B5 	90 MHz 	60 MHz 	600 nm 	CPGA-GC 	Socket 5/7 	SX957
SX958
SX959
A80502-90 	P54C 	0525h 	C2 	90 MHz 	60 MHz 	600 nm 	CPGA 	Socket 5/7 	SX968
A8050290
A80502-100 	P54C 	0525h 	C2 	100 MHz 	50/66 MHz 	600 nm 	CPGA 	Socket 5/7 	SX963
A80502100 	P54C 	0525h 	C2 	100 MHz 	50/66 MHz 	600 nm 	CPGA 	Socket 5/7 	SX963
SX970
A80502100 	P54C 	0526h 	E0 	100 MHz 	50/66 MHz 	600 nm 	CPGA 	Socket 5/7 	SY007
A80502120 	P54CQS 	0526h 	E0 	120 MHz 	60 MHz 	600 nm 	CPGA 	Socket 5/7 	SY033
A80502120 	P54CQS 	052Ch 	cC0 	120 MHz 	60 MHz 	600 nm 	CPGA 	Socket 5/7 	SY062
A80502-133 	P54CS 	0525h 	C2 	133 MHz 	66 MHz 	350 nm 	CPGA 	Socket 5/7 	SK098
A80502133 	P54CS 	052Bh 	cB1 	133 MHz 	66 MHz 	350 nm 	CPGA 	Socket 5/7 	S106J
SK106
A80502133 	P54CS 	052Ch 	cC0 	133 MHz 	66 MHz 	350 nm 	CPGA 	Socket 5/7 	SY022
A80502166 	P54CS 	052Ch 	cC0 	166 MHz 	66 MHz 	350 nm 	CPGA 	Socket 7 	SY016
SY017
FV80502166 	P54CS 	052Ch 	cC0 	166 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	SY037
FV80502200 	P54CS 	052Ch 	cC0 	200 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	SY045
FV80503166 	P55C 	0544h 	xA3 	166 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	Q019 ES
SY059
FV80503166 	P55C 	0543h 	xB1 	166 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	SL27H
A80503166 	P55C 	0543h 	xB1 	166 MHz 	66 MHz 	350 nm 	CPGA 	Socket 7 	SL27K
FV80503200 	P55C 	0544h 	xA3 	200 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	SL26J
A80503200 	P55C 	0543h 	xB1 	200 MHz 	66 MHz 	350 nm 	CPGA 	Socket 7 	SL2RY
FV80503200 	P55C 	0543h 	xB1 	200 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	SL27J
FV80503233 	P55C 	0543h 	xB1 	233 MHz 	66 MHz 	350 nm 	PPGA 	Socket 7 	SL27S

Pentium Pro
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
KB80521EX180 256K 	P6 	0617h 	sA1 	180 MHz 	60 MHz 	350 nm 	CPGA-GC 	Socket 8 	SY039
KB80521EX200 256K 	P6 	0619h 	sB1 	200 MHz 	66 MHz 	350 nm 	CPGA-GC 	Socket 8 	SL22T
SL22V
GJ80521EX200 1M 	P6 	0619h 	sB1 	200 MHz 	66 MHz 	350 nm 	PPGA 	Socket 8 	SL259
SL25A

Pentium III / Celeron
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
Celeron 466 	Mendocino 	0665h 	B0 	466 MHz 	66 MHz 	250 nm 	PPGA 	Socket 370 	SL3EH
Celeron 500 	Mendocino 	0665h 	B0 	500 MHz 	66 MHz 	250 nm 	PPGA 	Socket 370 	SL3LQ
Celeron 600 	Coppermine 	0683h 	B0 	600 MHz 	66 MHz 	180 nm 	FCPGA 	Socket 370 	SL3W8
Celeron 633 	Coppermine 	0683h 	B0 	633 MHz 	66 MHz 	180 nm 	FCPGA 	Socket 370 	SL3VS
Celeron 700 	Coppermine 	0683h 	B0 	700 MHz 	66 MHz 	180 nm 	FCPGA 	Socket 370 	SL48F
Celeron 700 	Coppermine 	0686h 	C0 	700 MHz 	66 MHz 	180 nm 	FCPGA 	Socket 370 	SL4P8
Celeron 800 	Coppermine 	068Ah 	D0 	800 MHz 	100 MHz 	180 nm 	FCPGA 	Socket 370 	SL54P
Pentium III 650 	Coppermine 	0683h 	cB0 	650 MHz 	100 MHz 	180 nm 	FCPGA 	Socket 370 	SL3XV
Pentium III 667 	Coppermine 	0681h 	cA2 	667 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL3VK
Pentium III 700 	Coppermine 	0686h 	cC0 	750 MHz 	100 MHz 	180 nm 	FCPGA 	Socket 370 	SL4CH
Pentium III 750 	Coppermine 	0683h 	cB0 	750 MHz 	100 MHz 	180 nm 	FCPGA 	Socket 370 	SL462
Pentium III 800 	Coppermine 	0683h 	cB0 	800 MHz 	100 MHz 	180 nm 	FCPGA 	Socket 370 	SL3Y3
Pentium III 800 	Coppermine 	0686h 	cC0 	800 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL4CD
Pentium III 866 	Coppermine 	0683h 	cB0 	866 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL43J
Pentium III 866 	Coppermine 	0686h 	cC0 	866 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL4MD
Pentium III 933 	Coppermine 	0686h 	cC0 	933 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL4C9
Pentium III 933 	Coppermine 	068Ah 	cD0 	933 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL52Q
Pentium III 1000 	Coppermine 	0686h 	cC0 	1000 MHz 	133 MHz 	180 nm 	FCPGA 	Socket 370 	SL4C8
Celeron 1200 	Tualatin 	06B1h 	tA1 	1200 MHz 	100 MHz 	130 nm 	FCPGA2 	Socket 370 	SL5XS
Celeron 1300 	Tualatin 	06B1h 	tA1 	1300 MHz 	100 MHz 	130 nm 	FCPGA2 	Socket 370 	SL5VR
Celeron 1300 	Tualatin 	06B4h 	tB1 	1300 MHz 	100 MHz 	130 nm 	FCPGA2 	Socket 370 	SL6C7

Pentium 4 / Pentium 4 HT / Celeron / Celeron D / Xeon
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
Celeron 1.7 	Willamette 	0F13h 	E0 	1700 MHz 	100 MHz 	180 nm 	µFCPGA 	Socket 478 	SL68C
SL69Z
Pentium 4 1.5 	Willamette 	0F07h 	B2 	1500 MHz 	100 MHz 	180 nm 	OLGA 	Socket 423 	SL4SH
Pentium 4 1.6 	Willamette 	0F12h 	D0 	1600 MHz 	100 MHz 	180 nm 	µFCPGA 	Socket 478 	SL5VH
Pentium 4 1.7 	Willamette 	0F12h 	D0 	1700 MHz 	100 MHz 	180 nm 	µFCPGA 	Socket 478 	SL5UG
Pentium 4 1.7 	Willamette 	0F13h 	E0 	1700 MHz 	100 MHz 	180 nm 	µFCPGA 	Socket 478 	SL67A
Pentium 4 1.8 	Willamette 	0F12h 	D0 	1800 MHz 	100 MHz 	180 nm 	µFCPGA 	Socket 478 	SL5UK
Celeron 2.0 	Northwood 	0F27h 	C1 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6HY
SL6SW
Celeron 2.0 	Northwood 	0F29h 	D1 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6VR
Celeron 2.4 	Northwood 	0F29h 	D1 	2400 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6VU
SL6W4
Celeron 2.6 	Northwood 	0F29h 	D1 	2600 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6W5
Pentium 4 1.8A 	Northwood 	0F27h 	C1 	1800 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6LA
Pentium 4 2.0A 	Northwood 	0F24h 	B0 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL5YR
Pentium 4 2.0 	Northwood 	0F27h 	C1 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6GQ
Pentium 4 2.0 	Northwood 	0F29h 	D1 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6PK
Pentium 4 2.26 	Northwood 	0F24h 	B0 	2266 MHz 	133 MHz 	130 nm 	µFCPGA 	Socket 478 	SL683
Pentium 4 2.4 	Northwood 	0F27h 	C1 	2400 MHz 	133 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6EF
SL6SH
Pentium 4 2.4 	Northwood 	0F29h 	D1 	2400 MHz 	133 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6PC
Pentium 4 2.8 	Northwood 	0F29h 	D1 	2800 MHz 	133 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6PF
Pentium 4 HT 2.4C 	Northwood 	0F29h 	D1 	2400 MHz 	200 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6WF
Celeron D 320 	Prescott 	0F34h 	D0 	2400 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL7JV
SL7KX
Celeron D 320 	Prescott 	0F41h 	E0 	2666 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL87J
Celeron D 325 	Prescott 	0F33h 	C0 	2533 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL7C5
Celeron D 330 	Prescott 	0F33h 	C0 	2666 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL7C6
Celeron D 330 	Prescott 	0F41h 	E0 	2666 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL7NV
Celeron D 331 	Prescott 	0F49h 	G1 	2666 MHz 	133 MHz 	90 nm 	FC-LGA4 	Socket 775 	SL98V
Celeron D 340 	Prescott 	0F34h 	D0 	2933 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL7Q9
Celeron D 340 	Prescott 	0F41h 	E0 	2933 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 478 	SL7TS
Pentium 4 HT 3.0E 	Prescott 	0F33h 	C0 	3000 MHz 	200 MHz 	90 nm 	µFCPGA 	Socket 478 	SL79L
Xeon 2.8 	Prestonia 	0F27h 	C1 	2800 MHz 	100 MHz 	130 nm 	OLGA 	Socket 603 	SL6M7
Xeon 2.8B 	Prestonia 	0F29h 	D1 	2800 MHz 	133 MHz 	130 nm 	µFCPGA 	Socket 604 	SL6VN

Core 2 Quad / Core 2 Duo / Pentium Dual-Core / Celeron Dual-Core / Celeron
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
Celeron 430 	Conroe-L 	10661h 	A1 	1800 MHz 	200 MHz 	65 nm 	FC-LGA4 	Socket 775 	SL9XN
E6700 	Wolfdale 	01067Ah 	R0 	3200 MHz 	266 MHz 	45 nm 	FC-LGA4 	Socket 775 	SLGUF
E8500 	Wolfdale 	01067Ah 	E0 	3167 MHz 	333 MHz 	45 nm 	FC-LGA4 	Socket 775 	SL9BK
Q8300 	Yorkfield 	01067Ah 	R0 	2500 MHz 	333 MHz 	45 nm 	FC-LGA4 	Socket 775 	SLGUR

Pentium 4-M / Mobile Pentium 4 / Mobile Celeron
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
Mobile Celeron 1.5 	Northwood 	0F24h 	B0 	1500 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6FN
Pentium 4-M 1.7 	Northwood 	0F27h 	C1 	1700 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6FG
Pentium 4-M 1.8 	Northwood 	0F24h 	B0 	1800 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL65Q
Pentium 4-M 2.0 	Northwood 	0F24h 	B0-Shrink 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6CL
Pentium 4-M 2.0 	Northwood 	0F27h 	C1 	2000 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 478 	SL6FK

Pentium M / Celeron M
model 	codename 	CPUID 	stepping 	freq. 	FSB 	process 	package 	socket 	sSpec
Celeron M 330 	Banias 	0695h 	B1 	1400 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 479 	SL6N6
Celeron M 340 	Banias 	0695h 	B1 	1500 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 479 	SL7ME
Pentium M 1.3 	Banias 	0695h 	B1 	1300 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 479 	SL6N4
Pentium M 1.4 	Banias 	0695h 	B1 	1400 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 479 	SL6F8
Pentium M 1.5 	Banias 	0695h 	B1 	1500 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 479 	SL6F9
Pentium M 1.6 	Banias 	0695h 	B1 	1600 MHz 	100 MHz 	130 nm 	µFCPGA 	Socket 479 	SL6FA
Celeron M 360 	Dothan 	06D6h 	B1 	1400 MHz 	100 MHz 	90 nm 	µFCPGA 	Socket 479 	SL7LS
Celeron M 370 	Dothan 	06D8h 	C0 	1500 MHz 	100 MHz 	90 nm 	µFCPGA 	Socket 479 	SL8MM
Pentium M 725 	Dothan 	06D6h 	B1 	1600 MHz 	100 MHz 	90 nm 	µFCPGA 	Socket 479 	SL7EG
Pentium M 730 	Dothan 	06D8h 	C0 	1600 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 479 	SL86G
Pentium M 740 	Dothan 	06D8h 	C0 	1733 MHz 	133 MHz 	90 nm 	µFCPGA 	Socket 479 	SL7SA

----------------------------------------

----------------------------------------


========================================

----------------------------------------

----------------------------------------

----------------------------------------
