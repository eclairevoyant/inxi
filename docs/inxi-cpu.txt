================================================================================
INXI CPU
================================================================================
FILE:    inxi-cpu.txt
VERSION: 1.0
DATE:    2022-06-14

----------------------------------------
Docs:
See: 

----------------------------------------
Code:
See:

----------------------------------------
Comments:

================================================================================
Sections:
CPU FUNCTIONS DATA
 CPU Flags
 
CPU DATA
 ARM
  Android
 cpu_sys()
 cp_cpu_arch()
 scaling / cpuinfo speeds
 Cache L1 L2 L3
 Topology
  CPU Dies
 FreeBSD
 DragonFly

================================================================================
CPU FUNCTIONS DATA
--------------------------------------------------------------------------------

========================================
CPU Flags
----------------------------------------

See: cpu-flags.txt for links, -Cx vs -f (short form vs full), and current 
listed flags definitions. Includes overview of the short form flag items 
so it's reasonably clear why those are the short form defaults.

========================================
cp_cpu_arch()
----------------------------------------

AMD CPU MICROARCHITECTURES:
https://en.wikipedia.org/wiki/List_of_AMD_CPU_microarchitectures

# fulll table of support!
https://en.wikipedia.org/wiki/Template:AMD_x86_CPU_features

https://www.techradar.com/news/rumored-problems-at-tsmc-could-delay-the-next-generation-of-amd-cpus

https://www.tomshardware.com/picturestory/735-history-of-amd-graphics-3.html

Intel CPUs
https://en.wikichip.org/wiki/intel#List_of_microarchitectures
https://www.intel.com/content/www/us/en/design/products-and-solutions/processors-and-chipsets/platform-codenames.html
product codes: https://en.wikipedia.org/wiki/List_of_Intel_microprocessors
https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers

https://en.wikipedia.org/wiki/Intel_Core

https://www.hp.com/us-en/shop/tech-takes/intel-processor-guide

This is really good:
https://en.wikichip.org/wiki/amd/cpuid
https://en.wikichip.org/wiki/intel/cpuid
combined with cpuinfo from:
https://intel-gfx-ci.01.org/hardware/

https://en.wikipedia.org/wiki/List_of_AMD_processors

https://www.hp.com/us-en/shop/tech-takes/intel-processor-guide
https://www.intel.com/content/www/us/en/support/articles/000032203/processors/intel-core-processors.html
https://www.intel.com/content/www/us/en/processors/processor-numbers.html

https://en.wikichip.org/wiki/intel/process_technology
# this is useful, lists process of each name, but note doesn't cover the multi
# gen code names like Comet lake etc.
https://en.wikichip.org/wiki/intel/microarchitectures
https://en.wikichip.org/wiki/intel/microarchitectures/netburst

https://pcgearlab.com/articles/how-to-check-intel-processor-generation/

AMD ZEN
https://en.wikipedia.org/wiki/Zen_(first_generation_microarchitecture)
https://en.wikipedia.org/wiki/Zen%2B
https://en.wikipedia.org/wiki/Zen_2
https://en.wikipedia.org/wiki/Zen_3

random data:
https://asteroidsathome.net/boinc/cpu_list.php
has model, family, stepping, but no way to match with familyarch, but otherwise good info
https://www.cpu-world.com/index.html

2014 list, useful for legacy processors, has model, family, and microarch, but isn't always
100% accurate. Prefer en.wikichip.org if there are disagreements
https://a4lg.com/tech/x86/database/x86-families-and-models.en.html

useful info in this one, includes EAX queries and possible values
https://en.wikipedia.org/wiki/CPUID
https://www.felixcloutier.com/x86/cpuid

https://github.com/gcc-mirror/gcc/blob/master/libgcc/config/i386/cpuinfo.c

Elbrus-S/E2K/2S+/2SM/4S/8S/8SV/16S russian x86/64 compatible:
https://wikivisually.com/wiki/Elbrus_%28computer%29
https://en.wikipedia.org/wiki/Elbrus-8S
https://wikivisually.com/wiki/Elbrus_2000
https://wikivisually.com/wiki/Elbrus-2S%2B

good tech overview of elbrus specs:
https://www.7-cpu.com/cpu/Elbrus.html

https://en.wikipedia.org/wiki/List_of_Russian_microprocessors

Elbrus 1S+ (SOC+gpu)

----------------------------------------
AMD: Manual, from external, IDs
----------------------------------------

These are from getting the id numbers off the cpu external body:

Note: the shell body often has a year that does not seem related to the release,

like 2001 for a socket 939, which came out 2004.

----------------------------------------

AMD Athlon 
id: A1400AMS3C
shell: 1999

cpu-world:
https://www.cpu-world.com/CPUs/K7/AMD-Athlon%201400%20-%20A1400AMS3C.html

AMD Package number	27016
Socket	Socket A (Socket 462)
Microarchitecture	K7
Processor core  ? 	Thunderbird (Model 4)
Introduction date	6-Jun-01
CPUID	644
Manufacturing process	0.18 micron
37 million transistors
Family:	6 (06h)
Model:	4 (04h)
Stepping:	4 (04h)


----------------------------------------

AMD Athlon 64 3500+
id: ADA3500DEP4AS
shell: na

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%203500%2B%20-%20ADA3500DEP4AS%20(ADA3500ASBOX).html

Socket Socket 939
Introduction date Jun 1, 2004
Price at introduction $500
Microarchitecture K8
Processor core ? ClawHammer
Core stepping ? SH-CG
CPUID F7A
Family: 15 (0Fh)
Model: 7 (07h)
Stepping: 10 (0Ah)

----------------------------------------

AMD Athlon 64 3500+
id: ADA3500DAA4BW
shell: na

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%203500%2B%20-%20ADA3500DAA4BW%20(ADA3500BWBOX).html

Microarchitecture K8
Processor core ? Venice
Core stepping ? DH-E6
CPUID 20FF2
Manufacturing process 0.09 micron silicon-on-insulator (SOI) technology
Data width 64 bit
The number of CPU cores 1
The number of threads 1
Family: 15 (0Fh)
Model: 47 (02Fh)
Stepping: 2 (02h)

----------------------------------------

AMD Sempron 2200+: A1908810
ID: SDA2200DUT3D
shell: 1999

cpu-world:
https://www.cpu-world.com/CPUs/K7/AMD-Sempron%202200%2B%20-%20SDA2200DUT3D%20(SDA2200BOX).html

Thoroughbred
Socket	Socket A (Socket 462)
Introduction date	July 28, 2004 [this has to be wrong]
Microarchitecture	K7
Processor core  ? 	Thoroughbred (Model 8)
CPUID	681
Manufacturing process	0.13 micron
CPUID signature:	681
Family:	6 (06h)
Model:	8 (08h)
Stepping:	1 (01h)

----------------------------------------

AMD Athlon 64 X2
id: ADA3800DAASBV

shell: 2001

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%20X2%203800%2B%20-%20ADA3800DAA5BV%20(ADA3800BVBOX).html

Family	AMD Athlon 64 X2
Microarchitecture	K8
Processor core  ? 	Manchester
Socket	Socket 939
Processor core  ? 	Manchester
Introduction date	Aug 1, 2005
CPUID	20FB1
Manufacturing process	0.09 micron
150 million transistors
Family:	15 (0Fh)
Model:	43 (02Bh)
Stepping:	1 (01h)

----------------------------------------

AMD Athlon 64 X2
id: AD04800IA5DD
shell: 2005

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%20X2%204800%2B%20-%20ADO4800IAA5DD%20(ADO4800DDBOX).html

Family	AMD Athlon 64 X2
Socket	Socket AM2
Introduction date	Dec 5, 2006
Microarchitecture	K8
Platform	Cartwheel
Processor core  ? 	Brisbane
Manufacturing process	0.065 micron silicon-on-insulator (SOI) technology
221 million transistors
Family:	15 (0Fh)
Model:	107 (06Bh)
Stepping:	1 (01h)

----------------------------------------

AMD Athlon 64
id: ADA3200AEP4AX
shell: 2001

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%203200%2B%20-%20ADA3200AEP4AX%20(ADA3200AXBOX).html

Family	AMD Athlon 64
Socket	Socket 754
Microarchitecture	K8
Processor core  ? 	NewCastle
Manufacturing process	0.13 micron silicon-on-insulator (SOI) technology
Intro date: NA
Family:	15 (0Fh)
Model:	12 (0Ch)
Stepping:	0 (00h)

----------------------------------------

AMD Athlon 64 X2
id: ADA3800DAA5CD
shell: 2001

cpu-world:
https://www.cpu-world.com/CPUs/K8/AMD-Athlon%2064%20X2%203800%2B%20-%20ADA3800DAA5CD%20(ADA3800CDBOX).html

Family	AMD Athlon 64 X2
Socket	Socket 939
Introduction date	Aug 1, 2005
Microarchitecture	K8
Processor core  ? 	Toledo
CPUID	20F32
Manufacturing process	0.09 micron
150 million transistors
Family:	15 (0Fh)
Model:	35 (023h)
Stepping:	2 (02h)

----------------------------------------

AMD Athlon XP 2000+
package number: 27111
shell: na

cpu-world:
https://www.cpu-world.com/CPUs/K7/AMD-Athlon%20XP%202000+%20-%20AX2000DMT3C.html

Socket	Socket A (Socket 462)
Microarchitecture	K7
Processor core  ? 	Palomino (Model 6)
Manufacturing process	0.18 micron copper process
Family:	6 (06h)
Model:	6 (06h)
Stepping:	2 (02h)


----------------------------------------

----------------------------------------
Intel: Manual, from external, IDs
----------------------------------------

# from the cpu shell
Intel Celeron
id: FV524RX500
S-Spec: SL3FY
Cache: 128 KB
Shell year: 1998

https://www.cpu-world.com/sspec/SL/SL3FY.html
# from cpu-world
Socket: Socket 370 
Price at introduction: ?
Microarchitecture: Celeron
Processor core: Mendicino
Process: 250 nm
Core stepping: B0
CPUID: 665 (0665h)
Family: 6 (06h)
Model: 6 (06h)
Stepping: 5 (05h)

# from wikipedia.org
https://en.wikipedia.org/wiki/List_of_Intel_Celeron_processors
Introduction date: August 1999

========================================
set_cpu_speeds_sys()
----------------------------------------

ARM ODROID CPU SPEEDS:
https://github.com/smxi/inxi/issues/128

========================================
cpu_dmi_data()
----------------------------------------

https://en.wikipedia.org/wiki/CPU_socket

========================================
data_cpuinfo()
----------------------------------------

RYZEN:
https://www.pcworld.com/article/3214635/components-processors/ryzen-threadripper-review-we-test-amds-monster-cpu.html
INTEL:
https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers
https://en.wikipedia.org/wiki/List_of_Intel_microprocessors
https://github.com/pytorch/cpuinfo/blob/master/src/x86/uarch.c
http://www.cpu-world.com/
https://en.wikichip.org/wiki/intel/cpuid

# intel dies etc, pcie, dmi 2.0/3.0
https://www.anandtech.com/show/10303/choosing-the-right-ssd-for-a-skylakeu-system
https://h30434.www3.hp.com/t5/Notebook-Hardware-and-Upgrade-Questions/And-this-is-why-my-960-evo-can-t-get-3200MB-s-on-my-spectre/td-p/5975464

# commit for complex /proc/cpuinfo options
Add Alder Lake support for perf (kernel)
https://lwn.net/Articles/851479/

# lists of datasets
https://intel-gfx-ci.01.org/hardware/

# about Elbrus:
https://www.7-cpu.com/cpu/Elbrus.html

# bogomips from many cpus!
https://tldp.org/HOWTO/BogoMips/bogo-list.html

========================================
cpu_bugs_sys()
----------------------------------------

http://kroah.com/log/blog/2018/01/06/meltdown-status/

https://www.maketecheasier.com/check-linux-meltdown-spectre-vulnerability/

========================================
cpu_sys()
----------------------------------------

https://www.kernel.org/doc/html/v4.14/admin-guide/pm/cpufreq.html
https://www.codeblueprint.co.uk/2019/11/05/does-smt-make-sense.html

Security/SMT
https://www.theregister.com/2019/10/29/intel_disable_hyper_threading_linux_kernel_maintainer/
----------------------------------------
cpu frequencies /proc/cpuinfo
 Bug 197009
Summary: /proc/cpuinfo does not update frequency
https://bugzilla.kernel.org/show_bug.cgi?id=197009

https://bugzilla.kernel.org/show_bug.cgi?id=211791

scaling_cur_freq takes 10ms to read:
https://github.com/htop-dev/htop/issues/471

@KonstantinPlotnikov what is the cpufreq driver on each of these systems?
LANG=C cpufreq-info | grep driver will show.

https://stackoverflow.com/questions/3021054/how-to-read-cpu-frequency-on-android-device
Awesome answer Ellis, you really helped me a lot. One thing that I found in investigating this was that scaling_cur_freq is not necessarily the current CPU frequency, but rather what the kernel thinks the frequency is. To get the real frequency, you need root access to read cpuinfo_cur_freq. Also, gaining root access allows you to set the cpu speed, which is quite useful for profiling under best/worst case conditions. 

time cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq
time cat /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq

There seems to be no standardisation of the /proc/cpuinfo content, see https://manpages.debian.org/unstable/manpages/proc.5.en.html , but reading https://bugzilla.kernel.org/show_bug.cgi?id=197009 it should contain the current CPU frequency.
https://manpages.debian.org/unstable/manpages/proc.5.en.html ,
https://bugzilla.kernel.org/show_bug.cgi?id=197009 

cpuinfo_cur_freq vs scaling_cur_freq
https://github.com/prometheus/procfs/issues/122

 Instantaneous vs. cummulative cpufreq stats #428 
https://github.com/prometheus/procfs/issues/428

https://www.google.com/search?domains=lkml.org&q=scaling_cur_freq&sa=Google+Search&sitesearch=lkml.org&client=pub-3128732077138691&forid=1&ie=UTF-8&oe=UTF-8&flav=0000&sig=IZwGi0IG8Xeqz31p&cof=GALT%3A%23008000%3BGL%3A1%3BDIV%3A%23336699%3BVLC%3A663399%3BAH%3Acenter%3BBGC%3AFFFFFF%3BLBGC%3Adde8e8%3BALC%3A0000FF%3BLC%3A0000FF%3BT%3A000000%3BGFNT%3A0000FF%3BGIMP%3A0000FF%3BFORID%3A1&hl=en

# lkml cpuinfo 
CPU: Always show current CPU frequency in /proc/cpuinfo
https://lkml.org/lkml/2018/1/8/360

To that end, modify the /proc/cpuinfo implementation on x86 to use
aperfmperf_snapshot_khz() to snapshot the APERF and MPERF feedback
registers, if available, and use their values to compute the CPU
frequency to be reported as "cpu MHz".

However, do that carefully enough to avoid accumulating delays that
lead to unacceptable access times for /proc/cpuinfo on systems with
many CPUs.  Run aperfmperf_snapshot_khz() once on all CPUs
asynchronously at the /proc/cpuinfo open time, add a single delay
upfront (if necessary) at that point and simply compute the current
frequency while running show_cpuinfo() for each individual CPU.

Also, to avoid slowing down /proc/cpuinfo accesses too much, reduce
the default delay between consecutive APERF and MPERF reads to 10 ms,
which should be sufficient to get large enough numbers for the
frequency computation in all cases.

----------------------------------------------------
Calculate MHz using APERF/MPERF for cpuinfo and scaling_cur_freq
https://lkml.org/lkml/2016/4/1/7

From: Len Brown <len.brown@intel.com>

For x86 processors with APERF/MPERF and TSC,
return meaningful and consistent MHz in
/proc/cpuinfo and
/sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq

MHz is computed like so:

MHz = base_MHz * delta_APERF / delta_MPERF

MHz is the average frequency of the busy processor
over a measurement interval.  The interval is
defined to be the time between successive reads
of the frequency on that processor, whether from
/proc/cpuinfo or from sysfs cpufreq/scaling_cur_freq.
As with previous methods of calculating MHz,
idle time is excluded.

base_MHz above is from TSC calibration global "cpu_khz".

This x86 native method to calculate MHz returns a meaningful result
no matter if P-states are controlled by hardware or firmware
and/or the Linux cpufreq sub-system is/is-not installed.

Note that frequent or concurrent reads of /proc/cpuinfo
or sysfs cpufreq/scaling_cur_freq will shorten the
measurement interval seen by each reader.  The code
mitigates that issue by caching results for 100ms.

Discerning users are encouraged to take advantage of
the turbostat(8) utility, which can gracefully handle
concurrent measurement intervals of arbitrary length.

================================================================================
CPU DATA
--------------------------------------------------------------------------------

========================================
ARM
----------------------------------------

https://unix.stackexchange.com/questions/255558/understanding-the-output-of-proc-cpuinfo
explanation of the various lines in /proc/cpuinfo

eg:
$ cat /proc/cpuinfo
Processor : AArch64 Processor rev 3 (aarch64)
processor : 0
processor : 1
processor : 2
processor : 3
processor : 4
processor : 5
processor : 6
processor : 7
Features : fp asimd evtstrm aes pmull sha1 sha2 crc32
CPU implementer : 0x41
CPU architecture: AArch64
CPU variant : 0x0
CPU part    : 0xd03
CPU revision    : 3

Hardware : HiKey Development Board

----------
This is the expected output to Arm based processors. All Serialized cores are shown in list with line breaks instead of separated processors. Features are evaluated by cpuinfo code, and only show if all cores support them


    CPU implementer: Your code means ARM;
    CPU architecture: AArch64 means 64 bit ARM board:
    CPU variant : Indicates the variant number of the processor, or "major revision". Yours is zero.
    CPU part: Part number. 0xd03 indicates Cortex-A53 processor.
    CPU revision: Indicates patch release or "minor revision". 3, in your case
    Hardware    : HiKey Development Board is self explanatory

----------------------------------------
Android
----------------------------------------
https://stackoverflow.com/questions/20775982/how-to-understand-the-information-of-my-android-processor

Processor : ARMv7 Processor rev 1 (v7l)
processor : 0
BogoMIPS : 212.33

processor : 1
BogoMIPS : 212.33

Features : swp half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpv4
CPU implementer : 0x41
CPU architecture: 7
CPU variant : 0x0
CPU part    : 0xc05
CPU revision    : 1   
Hardware : MSM8x25 U8951 BOARD
Revision : 0000
Serial : 0000000000000000

========================================
cp_cpu_arch()
----------------------------------------
https://www.hp.com/us-en/shop/tech-takes/intel-processor-guide
Intel Core processors, ranked by generation:

8th Generation, released 2017 to 2019; Coffee Lake, Kaby Lake, Whisky Lake
9th Generation, released 2018 to 2019; Coffee Lake Refresh (Desktop)
10th Generation, released 2019 to 2020; Comet Lake (Desktop), Ice Lake (Mobile)
11th Generation, released 2020 to 2021; Rocket Lake (Desktop, Comet Lake Refresh (Desktop), Tiger Lake (Mobile)

Intel Xeon processor generations:

Cooper Lake, 2020 to 2021; Xeon Gold, Xeon Platinum
Comet Lake, 2020 to 2021; Xeon W
Cascade lake, 2019 to 2020; Xeon Platinum, Xeon Gold, Xeon Silver, Xeon Bronze
Coffee Lake, 2018 to 2019; Xeon E

Intel Pentium processor generations:
Jasper Lake, 2021; Pentium Silver
Comet Lake, 2019 to 2020; Pentium Gold
Tiger Lake (Mobile), 2019 to 2020; Pentium Gold
Coffee Lake, 2018 to 2019; Pentium Gold

Intel Celeron processor generations
Jasper Lake, 2021; Celeron N
Comet Lake, 2019 to 2020; Celeron G5
Tiger Lake (Mobile), 2019 to 2020; Celeron 6305
Coffee Lake, 2018 to 2019; Celeron G4

https://www.intel.com/content/www/us/en/processors/processor-numbers.html

https://en.wikipedia.org/wiki/Intel_Core

https://www.pagetable.com/?p=18

How Itanium messed up Intel’s CPUID family IDs
2006-07-26 by Michael Steil	

Assigning internal version/family/model IDs to products is a non-trivial task, 
especially if there are several different families/architectures on your 
roadmap, and if the marketing names and target markets have no real correlation 
to the internal architecture.

At Intel, everything went wrong. On every modern x86 processor, the CPUID 
instruction returns, among other things, the family code of the CPU. The i486 
(1989) is family 4, Pentium (1993) and Pentium MMX (1997) are family 5, Pentium 
Pro (1995), Pentium 2 (1997), Pentium 3 (2000) and Pentium M (2003) are family 6 
(“P6 microarchitecture”).

https://blog.codinghorror.com/

# fulll table of support!
https://en.wikipedia.org/wiki/Template:AMD_x86_CPU_features
https://en.wikipedia.org/wiki/Athlon#Athlon_Thunderbird_(2000-2001)

https://www.reddit.com/r/Amd/comments/7rk6u2/when_and_why_did_amd_switch_from_tsmc_to_glofo/

https://www.notebookcheck.net/Intel-details-new-process-innovations-and-node-names-Alder-Lake-10-nm-Enhanced-SuperFin-is-now-Intel-7-Intel-20A-is-the-2-nm-process-for-2024.552398.0.html

Intel feels the numbers denoted to indicate a process node are "just numbers" 
and that there is an inherent inconsistency in the current naming scheme. 
Therefore, the company will no longer indicate the process node in terms of 
nanometers but will use a new numbering scheme as follows:

Intel 7: This is the new name for 10 nm Enhanced SuperFin process and will 
feature in Alder Lake (client, 2021) and Sapphire Rapids (datacenter, Q1 2022) 
processor families. Intel 7 is slated to offer a 10% to 15% performance increase 
over the current 10 nm SuperFin process. 

Intel 4: This is Intel's actual 7 nm part that uses extreme ultraviolet (EUV) 
lithography with an estimated 20% increase in performance-per-watt. Intel 4 will 
feature in products such as Meteor Lake (client) and Granite Rapids (datacenter) 
for production in 2H 2022 and shipping in 2023. The ultra-short EUV wavelength 
enables Intel to offer features such as 192 execution units (EUs) in Meteor 
Lake's iGPU and significantly enhanced core counts (up to 120?) for a dual-die 
Granite Rapids processor.

Intel 3: Intel 3 will see the final, maximum leverage of FinFET optimizations. 
FinFET first debuted with 22 nm Ivy Bridge processors back in 2011 and has since 
come a long way. Intel 3 uses increased EUV for an approximately 18% 
performance-per-watt increase over Intel 4 along with additional area 
improvements. Intel 3 will begin manufacturing in 2H 2023. 

Intel 20A: With Intel 20A, we are officially entering into the Angstrom era (10 
Angstrom = 1 nm). Intel 20A will see the introduction of a new transistor 
architecture named RibbonFET for faster transistor switching while achieving the 
same drive current in a smaller footprint. Debuting alongside RibbonFET is 
PowerVia, the company's first implementation of a backside power delivery 
mechanism that negates the need for power routing on the front of the wafer.

Intel 20A will ramp up in 2024 with Qualcomm expected to be one of the partners 
that will leverage this process node.

Intel 18A and beyond: Intel said that Intel 18A is already in development for 
early 2025. Intel 18A will use further refinements in RibbonFET and will be 
among the first to receive and deploy high numerical aperture (NA) EUV 
lithography in collaboration with lithography giant ASML. 

========================================
cpu_sys()
----------------------------------------
https://www.kernel.org/doc/html/v4.14/admin-guide/pm/cpufreq.html


Policy Interface in sysfs

During the initialization of the kernel, the CPUFreq core creates a sysfs 
directory (kobject) called cpufreq under /sys/devices/system/cpu/.

That directory contains a policyX subdirectory (where X represents an integer 
number) for every policy object maintained by the CPUFreq core. Each policyX 
directory is pointed to by cpufreq symbolic links under 
/sys/devices/system/cpu/cpuY/ (where Y represents an integer that may be 
different from the one represented by X) for all of the CPUs associated with (or 
belonging to) the given policy. The policyX directories in 
/sys/devices/system/cpu/cpufreq each contain policy-specific attributes (files) 
to control CPUFreq behavior for the corresponding policy objects (that is, for 
all of the CPUs associated with them).

Some of those attributes are generic. They are created by the CPUFreq core and 
their behavior generally does not depend on what scaling driver is in use and 
what scaling governor is attached to the given policy. Some scaling drivers also 
add driver-specific attributes to the policy directories in sysfs to control 
policy-specific aspects of driver behavior.

The generic attributes under /sys/devices/system/cpu/cpufreq/policyX/ are the 
following:

affected_cpus
    List of online CPUs belonging to this policy (i.e. sharing the hardware performance scaling interface represented by the policyX policy object).
bios_limit

    If the platform firmware (BIOS) tells the OS to apply an upper limit to CPU frequencies, that limit will be reported through this attribute (if present).

    The existence of the limit may be a result of some (often unintentional) BIOS settings, restrictions coming from a service processor or another BIOS/HW-based mechanisms.

    This does not cover ACPI thermal limitations which can be discovered through a generic thermal driver.

    This attribute is not present if the scaling driver in use does not support it.
cpuinfo_cur_freq

    Current frequency of the CPUs belonging to this policy as obtained from the hardware (in KHz).

    This is expected to be the frequency the hardware actually runs at. If that frequency cannot be determined, this attribute should not be present.
cpuinfo_max_freq
    Maximum possible operating frequency the CPUs belonging to this policy can run at (in kHz).
cpuinfo_min_freq
    Minimum possible operating frequency the CPUs belonging to this policy can run at (in kHz).
cpuinfo_transition_latency

    The time it takes to switch the CPUs belonging to this policy from one P-state to another, in nanoseconds.

    If unknown or if known to be so high that the scaling driver does not work with the ondemand governor, -1 (CPUFREQ_ETERNAL) will be returned by reads from this attribute.
related_cpus
    List of all (online and offline) CPUs belonging to this policy.
scaling_available_governors

    List of CPUFreq scaling governors present in the kernel that can be attached to this policy or (if the intel_pstate scaling driver is in use) list of scaling algorithms provided by the driver that can be applied to this policy.

    [Note that some governors are modular and it may be necessary to load a kernel module for the governor held by it to become available and be listed by this attribute.]
scaling_cur_freq

    Current frequency of all of the CPUs belonging to this policy (in kHz).

    In the majority of cases, this is the frequency of the last P-state requested by the scaling driver from the hardware using the scaling interface provided by it, which may or may not reflect the frequency the CPU is actually running at (due to hardware design and other limitations).

    Some architectures (e.g. x86) may attempt to provide information more precisely reflecting the current CPU frequency through this attribute, but that still may not be the exact current CPU frequency as seen by the hardware at the moment.
scaling_driver
    The scaling driver currently in use.
scaling_governor

    The scaling governor currently attached to this policy or (if the intel_pstate scaling driver is in use) the scaling algorithm provided by the driver that is currently applied to this policy.

    This attribute is read-write and writing to it will cause a new scaling governor to be attached to this policy or a new scaling algorithm provided by the scaling driver to be applied to it (in the intel_pstate case), as indicated by the string written to this attribute (which must be one of the names listed by the scaling_available_governors attribute described above).
scaling_max_freq

    Maximum frequency the CPUs belonging to this policy are allowed to be running at (in kHz).

    This attribute is read-write and writing a string representing an integer to it will cause a new limit to be set (it must not be lower than the value of the scaling_min_freq attribute).
scaling_min_freq

    Minimum frequency the CPUs belonging to this policy are allowed to be running at (in kHz).

    This attribute is read-write and writing a string representing a non-negative integer to it will cause a new limit to be set (it must not be higher than the value of the scaling_max_freq attribute).
scaling_setspeed

    This attribute is functional only if the userspace scaling governor is attached to the given policy.

    It returns the last frequency requested by the governor (in kHz) or can be written to in order to set a new frequency for the policy.


The boost File in sysfs

This file is located under /sys/devices/system/cpu/cpufreq/ and controls the 
“boost” setting for the whole system. It is not present if the underlying 
scaling driver does not support the frequency boost mechanism (or supports it, 
but provides a driver-specific interface for controlling it, like intel_pstate).

If the value in this file is 1, the frequency boost mechanism is enabled. This 
means that either the hardware can be put into states in which it is able to 
trigger boosting (in the hardware-based case), or the software is allowed to 
trigger boosting (in the software-based case). It does not mean that boosting is 
actually in use at the moment on any CPUs in the system. It only means a 
permission to use the frequency boost mechanism (which still may never be used 
for other reasons).

If the value in this file is 0, the frequency boost mechanism is disabled and 
cannot be used at all.

The only values that can be written to this file are 0 and 1.


Legacy AMD cpb Knob

The AMD powernow-k8 scaling driver supports a sysfs knob very similar to the 
global boost one. It is used for disabling/enabling the “Core Performance Boost” 
feature of some AMD processors.

If present, that knob is located in every CPUFreq policy directory in sysfs 
(/sys/devices/system/cpu/cpufreq/policyX/) and is called cpb, which indicates a 
more fine grained control interface. The actual implementation, however, works 
on the system-wide basis and setting that knob for one policy causes the same 
value of it to be set for all of the other policies at the same time.

That knob is still supported on AMD processors that support its underlying 
hardware feature, but it may be configured out of the kernel (via the 
CONFIG_X86_ACPI_CPUFREQ_CPB configuration option) and the global boost knob is 
present regardless. Thus it is always possible use the boost knob instead of the 
cpb one which is highly recommended, as that is more consistent with what all of 
the other systems do (and the cpb knob may not be supported any more in the 
future).

The cpb knob is never present for any processors without the underlying hardware 
feature (e.g. all Intel ones), even if the CONFIG_X86_ACPI_CPUFREQ_CPB 
configuration option is set.

https://lwn.net/Articles/254445/ legacy cpu_map in /sys cpu data. If it's legacy 
you can tell either by presence of cpu_map file or by value of files.

/sys/devices/system/cpu/cpu0/cache/index2/shared_cpu_map:["01"]

/sys/devices/system/cpu/cpu0/topology/core_siblings:["01"]
/sys/devices/system/cpu/cpu0/topology/thread_siblings:["01"]
/sys/devices/system/cpu/cpu0/topology/core_id:["0"]

 For a four-socket, dual-core Opteron machine the cache information looks like Table 5.2:

    	type	level	shared_cpu_map
    cpu0 	index0	Data	1	00000001
					index1	Instruction	1	00000001
					index2	Unified	2	00000001
    cpu1 	index0	Data	1	00000002
					index1	Instruction	1	00000002
					index2	Unified	2	00000002
    cpu2 	index0	Data	1	00000004
					index1	Instruction	1	00000004
					index2	Unified	2	00000004
    cpu3 	index0	Data	1	00000008
					index1	Instruction	1	00000008
					index2	Unified	2	00000008
    cpu4 	index0	Data	1	00000010
					index1	Instruction	1	00000010
					index2	Unified	2	00000010
    cpu5 	index0	Data	1	00000020
					index1	Instruction	1	00000020
					index2	Unified	2	00000020
    cpu6 	index0	Data	1	00000040
					index1	Instruction	1	00000040
					index2	Unified	2	00000040
    cpu7 	index0	Data	1	00000080
					index1	Instruction	1	00000080
					index2	Unified	2	00000080
    
 Table 5.3 shows the interesting files in this hierarchy for the SMP Opteron machine.

    	physical_
    package_id 	core_id 	core_
    siblings 	thread_
    siblings
    cpu0	0	0	00000003	00000001
    cpu1 	1	00000003	00000002
    cpu2	1	0	0000000c	00000004
    cpu3 	1	0000000c	00000008
    cpu4	2	0	00000030	00000010
    cpu5 	1	00000030	00000020
    cpu6	3	0	000000c0	00000040
    cpu7 	1	000000c0	00000080
    
Taking Table 5.2 and Table 5.3 together we can see that no CPU has hyper-threads 
(the thread_siblings bitmaps have one bit set), that the system in fact has four 
processors (physical_package_id 0 to 3), that each processor has t

https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-devices-system-cpu

========================================
scaling / cpuinfo speeds
----------------------------------------
https://unix.stackexchange.com/questions/87522/why-do-cpuinfo-cur-freq-and-proc-
cpuinfo-report-different-numbers

So what about cpuinfo_cur_freq?

This parameter has more to do with the specification of the CPU and which 
profile it's currently in, rather than anything useful with respect to how the 
CPU is currently operating. For actual operational telemetry I'd use the 
scaling_* kernel tunables.

========================================
Cache L1 L2 L3
----------------------------------------
https://techgearoid.com/articles/does-each-core-have-its-own-l1-and-l2-cache/

While most modern processors do have L1, L2, L3, and even L4 in more recent
ones, there are a few exceptions. Processors With L2 Cache SHARED

There most certainly are/were processors that have L1 cache per each core but
have a shared L2 cache.

The older Core 2 Duo, Pentium Dual Core and the lot had shared L2 cache.

The newer Enterprise and Server Level processors also share L2 cache between
their cores. The 2nd Generation Intel Xeon Phi (Knights Landing) are examples of
processors where L2 cache is shared.

https://community.intel.com/t5/Intel-Moderncode-for-Parallel/How-to-discover-which-caches-L1-L2-L3-are-shared-by-which-HW/td-p/874330


https://stackoverflow.com/questions/944966/how-are-cache-memories-shared-in-multicore-intel-cpus

good graph/charts of intel core architectures
https://www.realworldtech.com/sandy-bridge/2/

https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html

========================================
Topology
----------------------------------------

https://www.spinics.net/lists/linux-tip-commits/msg48756.html

topology: Create core_cpus and die_cpus sysfs attributes

Create CPU topology sysfs attributes: "core_cpus" and "core_cpus_list"

These attributes represent all of the logical CPUs that share the
same core.

These attriutes is synonymous with the existing "thread_siblings" and
"thread_siblings_list" attribute, which will be deprecated.

Create CPU topology sysfs attributes: "die_cpus" and "die_cpus_list".
These attributes represent all of the logical CPUs that share the
same die.

-thread_siblings:
+core_cpus:
 -	internal kernel map of cpuX's hardware threads within the same
- core as cpuX.
+ internal kernel map of CPUs within the same core.
+ (deprecated name: "thread_siblings")

-thread_siblings_list:
+core_cpus_list:
- human-readable list of cpuX's hardware threads within the same
- core as cpuX.
+ human-readable list of CPUs within the same core.
+ (deprecated name: "thread_siblings_list");

+die_cpus:
+
+ internal kernel map of CPUs within the same die.
+
+die_cpus_list:
+
+ human-readable list of CPUs within the same die.
+

----------------------------------------
CPU Dies
----------------------------------------

https://listman.redhat.com/archives/libvir-list/2020-January/msg00277.html

Latest generation CPUs (CascadeLake-AP) support a new topology level known as a 
'die sitting between a socket and a core.

QEMU supports this with -smp arg since 4.1.0

Linux can report this via /sys/devices/system/cpu/cpuNNN/topology via 'die_id' 
and 'die_cpus' and 'die_cpus_list' files since 5.2

This series adds support for <topology> in guest XML to have a new dies' 
parameter, passed to QEMU, which defaults to '1' if omitted.

It extends host capabilities so that NUMA topology reports a new die_id' 
attribute

We can't expand 'virNodeInfoPtr' struct to have a die field, so this will remain 
forever reporting 'cores' as being 'dies * cores'.

The <topology> in host capabilities XML is an interesting question.

If we are strict with our API semantics we would *not* add a 'dies' parameter 
with any value other than '1' to <topology> in the host capabilities. If we 
reported a value other than 1, then any existing apps which multiple  
sockets*cores*threads will get the wrong total CPU count.

We already know <topology> is broken by design for asymetric hardware, so we 
could simply document that it will forever be broken wrt to CPU dies too.  In 
this case we might be better to not even report 'dies=1 just leave out the attr 
entirely.

Interestingly though, <topology> is already more broken than it should be. For a 
VM with   -smp 12,sockets=2,dies=3,cores=2,threads=1 it is reporting <topology 
sockets=1 dies=1 cores=12 threads=1>. It should at least do  <topology sockets=2 
dies=1 cores=6 threads=1>.

I suspect the presence of dies is confusing the really incredibly horrible logic 
in virHostCPUGetInfoLinux. This will also impact virNodeInfoPtr data.

So even if we don't report dies, I think we still have a bug that needs fixing 
here for the coarse node topology.

I'm also confused about what I see with EPYC. IIUC, it was supposed to use the 
'dies' concept, but in machines I've tested, Linux never reports die count other 
than 1.  Perhaps only certain EPYC CPU models or generations use 'dies or 
perhaps Linux isn't reporting correctly for EPYC, or perhaps I'm mislead into 
believeing it uses dies.

Anyway, the upshot is I've not found any real hardware to test this series on. 
I've tested it only inside a QEMU guest with the suitable -smp arg to fake dies.

Daniel P. Berrangé (5):

========================================
FreeBSD:
----------------------------------------

kern.sched.topology_spec:<groups>
 <group level="1" cache-level="0">
  <cpu count="8" mask="ff">0, 1, 2, 3, 4, 5, 6, 7</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="8" mask="ff">0, 1, 2, 3, 4, 5, 6, 7</cpu>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
kern.sched.topology_spec: <groups>
 <group level="1" cache-level="0">
  <cpu count="4" mask="f">0, 1, 2, 3</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="4" mask="f">0, 1, 2, 3</cpu>
    <children>
     <group level="3" cache-level="1">
      <cpu count="2" mask="3">0, 1</cpu>
      <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
     </group>
     <group level="3" cache-level="1">
      <cpu count="2" mask="c">2, 3</cpu>
      <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
     </group>
    </children>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
2x 6 core xeon:

kern.sched.topology_spec: <groups>
 <group level="1" cache-level="0">
  <cpu count="12" mask="fff,0,0,0">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</cpu>
  <children>
   <group level="2" cache-level="3">
    <cpu count="6" mask="3f,0,0,0">0, 1, 2, 3, 4, 5</cpu>
    <children>
     <group level="3" cache-level="2">
      <cpu count="1" mask="1,0,0,0">0</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="2,0,0,0">1</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="4,0,0,0">2</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="8,0,0,0">3</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="10,0,0,0">4</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="20,0,0,0">5</cpu>
     </group>
    </children>
   </group>
   <group level="2" cache-level="3">
    <cpu count="6" mask="fc0,0,0,0">6, 7, 8, 9, 10, 11</cpu>
    <children>
     <group level="3" cache-level="2">
      <cpu count="1" mask="40,0,0,0">6</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="80,0,0,0">7</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="100,0,0,0">8</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="200,0,0,0">9</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="400,0,0,0">10</cpu>
     </group>
     <group level="3" cache-level="2">
      <cpu count="1" mask="800,0,0,0">11</cpu>
     </group>
    </children>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
inxi-BSD-freebsd-ThinkBSD-2020-09:
 Info: Quad Core model: Intel Core i5-3230M 

kern.smp.topology: 0
kern.smp.cpus: 4
kern.smp.disabled: 0
kern.smp.active: 1
kern.smp.maxcpus: 256
kern.smp.maxid: 3
...
kern.sched.topology_spec: <groups>
 <group level="1" cache-level="3">
  <cpu count="4" mask="f,0,0,0">0, 1, 2, 3</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="2" mask="3,0,0,0">0, 1</cpu>
    <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
   </group>
   <group level="2" cache-level="2">
    <cpu count="2" mask="c,0,0,0">2, 3</cpu>
    <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
   </group>
  </children>
 </group>
</groups>
----------------------------------------
inxi-BSD-freebsd-TinyBSD-2020-09
 Info: Dual Core model: Intel Atom N270 
 
kern.smp.forward_signal_enabled: 1
kern.smp.topology: 0
kern.smp.cpus: 2
kern.smp.disabled: 0
kern.smp.active: 1
kern.smp.maxcpus: 32
kern.smp.maxid: 1

kern.sched.topology_spec: <groups>
 <group level="1" cache-level="2">
  <cpu count="2" mask="3">0, 1</cpu>
  <flags><flag name="THREAD">THREAD group</flag><flag name="SMT">SMT group</flag></flags>
 </group>
</groups>
----------------------------------------
inxi-bsd-rianav.bsd.cdm-201405
FreeBSD 10.0-STABLE

CPU: core AMD Athlon II X2 245 ()

kern.sched.topology_spec: <groups>
 <group level="1" cache-level="0">
  <cpu count="2" mask="3">0, 1</cpu>
  <children>
   <group level="2" cache-level="2">
    <cpu count="2" mask="3">0, 1</cpu>
   </group>
  </children>
 </group>
</groups>

----------------------------------------
inxi-bsd-itwjyg.local-201405
Dual core Intel Core2 Duo P8600 (SMP) cache: 3145.73

Distro: Mac OS X 10.9.2 ... lol...

========================================
DRAGONFLY:
----------------------------------------
inxi-bsd-dflybsd.local-201409

hw.cpu_topology.tree:
\-PACKAGE MEMBERS: cpu0 cpu1
  \-CHIP ID 0: cpu0 cpu1 
    |-CORE ID 0: cpu0 
    \-CORE ID 1: cpu1 

hw.cpu_topology.level_description: 0 - core; 1 - socket; 2 - anything
hw.cpu_topology.members: cpu0 cpu1
hw.cpu_topology.cpu0.physical_id: 0
hw.cpu_topology.cpu0.physical_siblings: cpu0 cpu1
hw.cpu_topology.cpu0.core_id: 0
hw.cpu_topology.cpu0.core_siblings: cpu0
hw.cpu_topology.cpu1.physical_id: 0
hw.cpu_topology.cpu1.physical_siblings: cpu0 cpu1
hw.cpu_topology.cpu1.core_id: 1
hw.cpu_topology.cpu1.core_siblings: cpu1
----------------------------------------
hw.cpu_topology.tree:
\-PACKAGE MEMBERS: cpus(0-1)
  \-CHIP ID 0: cpus(0-1) 
    \-CORE ID 0: cpus(0-1) 
      |-THREAD ID 0: cpus(0-0) 
      \-THREAD ID 1: cpus(1-1) 

hw.cpu_topology.level_description: 0 - thread; 1 - core; 2 - socket; 3 - anything
hw.cpu_topology.members: cpus(0-1)
hw.cpu_topology.cpu0.physical_id: 0
hw.cpu_topology.cpu0.physical_siblings: cpus(0-1)
hw.cpu_topology.cpu0.core_id: 0
hw.cpu_topology.cpu0.core_siblings: cpus(0-1)
hw.cpu_topology.cpu1.physical_id: 0
hw.cpu_topology.cpu1.physical_siblings: cpus(0-1)
hw.cpu_topology.cpu1.core_id: 0
hw.cpu_topology.cpu1.core_siblings: cpus(0-1)

----------------------------------------
https://askubuntu.com/questions/1318432/cpufreq-is-missing-from-sys-devices-system-cpu-cpu0
note: in some cases, /sys/devices/system/cpu/cpu0/cpufreq does not exist, maybe
if scaling driver missing, don't know.

----------------------------------------
https://android.googlesource.com/kernel/common/+/a7827a2a60218b25f222b54f77ed38f57aebe08b/Documentation/cpu-freq/user-guide.txt

3.1 Preferred Interface: sysfs
------------------------------
The preferred interface is located in the sysfs filesystem. If you
mounted it at /sys, the cpufreq interface is located in a subdirectory
"cpufreq" within the cpu-device directory
(e.g. /sys/devices/system/cpu/cpu0/cpufreq/ for the first CPU).
cpuinfo_min_freq :		this file shows the minimum operating
				frequency the processor can run at(in kHz) 
cpuinfo_max_freq :		this file shows the maximum operating
				frequency the processor can run at(in kHz) 
cpuinfo_transition_latency The time it takes on this CPU to
				switch between two frequencies in nano
				seconds. If unknown or known to be
				that high that the driver does not
				work with the ondemand governor, -1
				(CPUFREQ_ETERNAL) will be returned.
				Using this information can be useful
				to choose an appropriate polling
				frequency for a kernel governor or
				userspace daemon. Make sure to not
				switch the frequency too often
				resulting in performance loss.
scaling_driver :		this file shows what cpufreq driver is
				used to set the frequency on this CPU
scaling_available_governors :	this file shows the CPUfreq governors
				available in this kernel. You can see the
				currently activated governor in
scaling_governor, and by "echoing" the name of another
				governor you can change it. Please note
				that some governors won't load - they only
				work on some specific architectures or
				processors.
cpuinfo_cur_freq :		Current frequency of the CPU as obtained from
				the hardware, in KHz. This is the frequency
				the CPU actually runs at.
scaling_available_frequencies : List of available frequencies, in KHz.
scaling_min_freq and
scaling_max_freq show the current "policy limits" (in
				kHz). By echoing new values into these
				files, you can change these limits.
				NOTE: when setting a policy you need to
				first set scaling_max_freq, then
				scaling_min_freq.
affected_cpus :			List of CPUs that require software coordination
				of frequency.
related_cpus :			List of CPUs that need some sort of frequency
				coordination, whether software or hardware.
scaling_driver :		Hardware driver for cpufreq.
scaling_cur_freq :		Current frequency of the CPU as determined by
				the governor and cpufreq core, in KHz. This is
				the frequency the kernel thinks the CPU runs
				at.
bios_limit :			If the BIOS tells the OS to limit a CPU to
				lower frequencies, the user can read out the
				maximum available frequency from this file.
				This typically can happen through (often not
				intended) BIOS settings, restrictions
				triggered through a service processor or other
				BIOS/HW based implementations.
				This does not cover thermal ACPI limitations
				which can be detected through the generic
				thermal driver.
If you have selected the "userspace" governor which allows you to
set the CPU operating frequency to a specific value, you can read out
the current frequency in
scaling_setspeed. By "echoing" a new frequency into this
				you can change the speed of the CPU,
				but only within the limits of
				scaling_min_freq and scaling_max_freq.

========================================

----------------------------------------

----------------------------------------

----------------------------------------

================================================================================

--------------------------------------------------------------------------------

========================================

----------------------------------------

----------------------------------------

----------------------------------------

